// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef PROTOBUF_Protocol_2eproto__INCLUDED
#define PROTOBUF_Protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsMsgLoginImpl();
void InitDefaultsMsgLogin();
void InitDefaultsMsgJoinTableImpl();
void InitDefaultsMsgJoinTable();
void InitDefaultsMsgLeaveTableImpl();
void InitDefaultsMsgLeaveTable();
void InitDefaultsMsgRaiseImpl();
void InitDefaultsMsgRaise();
void InitDefaultsMsgFoldImpl();
void InitDefaultsMsgFold();
void InitDefaultsMsgCallImpl();
void InitDefaultsMsgCall();
void InitDefaultsMsgCardImpl();
void InitDefaultsMsgCard();
void InitDefaultsMsgPlayerImpl();
void InitDefaultsMsgPlayer();
void InitDefaultsMsgTableInfoImpl();
void InitDefaultsMsgTableInfo();
void InitDefaultsMsgLobbyViewImpl();
void InitDefaultsMsgLobbyView();
void InitDefaultsMsgTableViewImpl();
void InitDefaultsMsgTableView();
inline void InitDefaults() {
  InitDefaultsRequest();
  InitDefaultsResponse();
  InitDefaultsMsgLogin();
  InitDefaultsMsgJoinTable();
  InitDefaultsMsgLeaveTable();
  InitDefaultsMsgRaise();
  InitDefaultsMsgFold();
  InitDefaultsMsgCall();
  InitDefaultsMsgCard();
  InitDefaultsMsgPlayer();
  InitDefaultsMsgTableInfo();
  InitDefaultsMsgLobbyView();
  InitDefaultsMsgTableView();
}
}  // namespace protobuf_Protocol_2eproto
class MsgCall;
class MsgCallDefaultTypeInternal;
extern MsgCallDefaultTypeInternal _MsgCall_default_instance_;
class MsgCard;
class MsgCardDefaultTypeInternal;
extern MsgCardDefaultTypeInternal _MsgCard_default_instance_;
class MsgFold;
class MsgFoldDefaultTypeInternal;
extern MsgFoldDefaultTypeInternal _MsgFold_default_instance_;
class MsgJoinTable;
class MsgJoinTableDefaultTypeInternal;
extern MsgJoinTableDefaultTypeInternal _MsgJoinTable_default_instance_;
class MsgLeaveTable;
class MsgLeaveTableDefaultTypeInternal;
extern MsgLeaveTableDefaultTypeInternal _MsgLeaveTable_default_instance_;
class MsgLobbyView;
class MsgLobbyViewDefaultTypeInternal;
extern MsgLobbyViewDefaultTypeInternal _MsgLobbyView_default_instance_;
class MsgLogin;
class MsgLoginDefaultTypeInternal;
extern MsgLoginDefaultTypeInternal _MsgLogin_default_instance_;
class MsgPlayer;
class MsgPlayerDefaultTypeInternal;
extern MsgPlayerDefaultTypeInternal _MsgPlayer_default_instance_;
class MsgRaise;
class MsgRaiseDefaultTypeInternal;
extern MsgRaiseDefaultTypeInternal _MsgRaise_default_instance_;
class MsgTableInfo;
class MsgTableInfoDefaultTypeInternal;
extern MsgTableInfoDefaultTypeInternal _MsgTableInfo_default_instance_;
class MsgTableView;
class MsgTableViewDefaultTypeInternal;
extern MsgTableViewDefaultTypeInternal _MsgTableView_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;

enum MsgError {
  MsgErrorSuccess = 0,
  MsgErrorWrongMessage = 1,
  MsgErrorInvalidValue = 2,
  MsgError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgError_IsValid(int value);
const MsgError MsgError_MIN = MsgErrorSuccess;
const MsgError MsgError_MAX = MsgErrorInvalidValue;
const int MsgError_ARRAYSIZE = MsgError_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgError_descriptor();
inline const ::std::string& MsgError_Name(MsgError value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgError_descriptor(), value);
}
inline bool MsgError_Parse(
    const ::std::string& name, MsgError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgError>(
    MsgError_descriptor(), name, value);
}
enum MsgTableStatus {
  MsgTableStatusUnknown = 0,
  MsgTableStatusWaitingForPlayers = 1,
  MsgTableStatusGameInProgress = 2,
  MsgTableStatusGameEnded = 3,
  MsgTableStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgTableStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgTableStatus_IsValid(int value);
const MsgTableStatus MsgTableStatus_MIN = MsgTableStatusUnknown;
const MsgTableStatus MsgTableStatus_MAX = MsgTableStatusGameEnded;
const int MsgTableStatus_ARRAYSIZE = MsgTableStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgTableStatus_descriptor();
inline const ::std::string& MsgTableStatus_Name(MsgTableStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgTableStatus_descriptor(), value);
}
inline bool MsgTableStatus_Parse(
    const ::std::string& name, MsgTableStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgTableStatus>(
    MsgTableStatus_descriptor(), name, value);
}
enum MsgRoundStatus {
  MsgRoundStatusUnknown = 0,
  MsgRoundStatusPreFlop = 1,
  MsgRoundStatusFlop = 2,
  MsgRoundStatusTurn = 3,
  MsgRoundStatusRiver = 4,
  MsgRoundStatusEnd = 5,
  MsgRoundStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgRoundStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgRoundStatus_IsValid(int value);
const MsgRoundStatus MsgRoundStatus_MIN = MsgRoundStatusUnknown;
const MsgRoundStatus MsgRoundStatus_MAX = MsgRoundStatusEnd;
const int MsgRoundStatus_ARRAYSIZE = MsgRoundStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgRoundStatus_descriptor();
inline const ::std::string& MsgRoundStatus_Name(MsgRoundStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgRoundStatus_descriptor(), value);
}
inline bool MsgRoundStatus_Parse(
    const ::std::string& name, MsgRoundStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgRoundStatus>(
    MsgRoundStatus_descriptor(), name, value);
}
enum MsgCardValue {
  MsgCardValueUnkown = 0,
  MsgCardValueTwo = 2,
  MsgCardValueThree = 3,
  MsgCardValueFour = 4,
  MsgCardValueFive = 5,
  MsgCardValueSix = 6,
  MsgCardValueSeven = 7,
  MsgCardValueEight = 8,
  MsgCardValueNine = 9,
  MsgCardValueTen = 10,
  MsgCardValueJack = 11,
  MsgCardValueQueen = 12,
  MsgCardValueKing = 13,
  MsgCardValueAce = 14,
  MsgCardValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgCardValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgCardValue_IsValid(int value);
const MsgCardValue MsgCardValue_MIN = MsgCardValueUnkown;
const MsgCardValue MsgCardValue_MAX = MsgCardValueAce;
const int MsgCardValue_ARRAYSIZE = MsgCardValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgCardValue_descriptor();
inline const ::std::string& MsgCardValue_Name(MsgCardValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgCardValue_descriptor(), value);
}
inline bool MsgCardValue_Parse(
    const ::std::string& name, MsgCardValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgCardValue>(
    MsgCardValue_descriptor(), name, value);
}
enum MsgCardSuit {
  MsgCardSuitUnkown = 0,
  MsgCardSuitSpades = 1,
  MsgCardSuitHearts = 2,
  MsgCardSuitDiamonds = 3,
  MsgCardSuitClubs = 4,
  MsgCardSuit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MsgCardSuit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MsgCardSuit_IsValid(int value);
const MsgCardSuit MsgCardSuit_MIN = MsgCardSuitUnkown;
const MsgCardSuit MsgCardSuit_MAX = MsgCardSuitClubs;
const int MsgCardSuit_ARRAYSIZE = MsgCardSuit_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgCardSuit_descriptor();
inline const ::std::string& MsgCardSuit_Name(MsgCardSuit value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgCardSuit_descriptor(), value);
}
inline bool MsgCardSuit_Parse(
    const ::std::string& name, MsgCardSuit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgCardSuit>(
    MsgCardSuit_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum PayloadCase {
    kLogin = 1,
    kJoinTable = 2,
    kLeaveTable = 3,
    kRaise = 4,
    kFold = 5,
    kCall = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .MsgLogin login = 1;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::MsgLogin& login() const;
  ::MsgLogin* release_login();
  ::MsgLogin* mutable_login();
  void set_allocated_login(::MsgLogin* login);

  // .MsgJoinTable joinTable = 2;
  bool has_jointable() const;
  void clear_jointable();
  static const int kJoinTableFieldNumber = 2;
  const ::MsgJoinTable& jointable() const;
  ::MsgJoinTable* release_jointable();
  ::MsgJoinTable* mutable_jointable();
  void set_allocated_jointable(::MsgJoinTable* jointable);

  // .MsgLeaveTable leaveTable = 3;
  bool has_leavetable() const;
  void clear_leavetable();
  static const int kLeaveTableFieldNumber = 3;
  const ::MsgLeaveTable& leavetable() const;
  ::MsgLeaveTable* release_leavetable();
  ::MsgLeaveTable* mutable_leavetable();
  void set_allocated_leavetable(::MsgLeaveTable* leavetable);

  // .MsgRaise raise = 4;
  bool has_raise() const;
  void clear_raise();
  static const int kRaiseFieldNumber = 4;
  const ::MsgRaise& raise() const;
  ::MsgRaise* release_raise();
  ::MsgRaise* mutable_raise();
  void set_allocated_raise(::MsgRaise* raise);

  // .MsgFold fold = 5;
  bool has_fold() const;
  void clear_fold();
  static const int kFoldFieldNumber = 5;
  const ::MsgFold& fold() const;
  ::MsgFold* release_fold();
  ::MsgFold* mutable_fold();
  void set_allocated_fold(::MsgFold* fold);

  // .MsgCall call = 6;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 6;
  const ::MsgCall& call() const;
  ::MsgCall* release_call();
  ::MsgCall* mutable_call();
  void set_allocated_call(::MsgCall* call);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Request)
 private:
  void set_has_login();
  void set_has_jointable();
  void set_has_leavetable();
  void set_has_raise();
  void set_has_fold();
  void set_has_call();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::MsgLogin* login_;
    ::MsgJoinTable* jointable_;
    ::MsgLeaveTable* leavetable_;
    ::MsgRaise* raise_;
    ::MsgFold* fold_;
    ::MsgCall* call_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum PayloadCase {
    kLobbyView = 2,
    kTableView = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .MsgError error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::MsgError error() const;
  void set_error(::MsgError value);

  // .MsgLobbyView lobbyView = 2;
  bool has_lobbyview() const;
  void clear_lobbyview();
  static const int kLobbyViewFieldNumber = 2;
  const ::MsgLobbyView& lobbyview() const;
  ::MsgLobbyView* release_lobbyview();
  ::MsgLobbyView* mutable_lobbyview();
  void set_allocated_lobbyview(::MsgLobbyView* lobbyview);

  // .MsgTableView tableView = 3;
  bool has_tableview() const;
  void clear_tableview();
  static const int kTableViewFieldNumber = 3;
  const ::MsgTableView& tableview() const;
  ::MsgTableView* release_tableview();
  ::MsgTableView* mutable_tableview();
  void set_allocated_tableview(::MsgTableView* tableview);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Response)
 private:
  void set_has_lobbyview();
  void set_has_tableview();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_;
  union PayloadUnion {
    PayloadUnion() {}
    ::MsgLobbyView* lobbyview_;
    ::MsgTableView* tableview_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class MsgLogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgLogin) */ {
 public:
  MsgLogin();
  virtual ~MsgLogin();

  MsgLogin(const MsgLogin& from);

  inline MsgLogin& operator=(const MsgLogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgLogin(MsgLogin&& from) noexcept
    : MsgLogin() {
    *this = ::std::move(from);
  }

  inline MsgLogin& operator=(MsgLogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgLogin* internal_default_instance() {
    return reinterpret_cast<const MsgLogin*>(
               &_MsgLogin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MsgLogin* other);
  friend void swap(MsgLogin& a, MsgLogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgLogin* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgLogin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgLogin& from);
  void MergeFrom(const MsgLogin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgLogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:MsgLogin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgLoginImpl();
};
// -------------------------------------------------------------------

class MsgJoinTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgJoinTable) */ {
 public:
  MsgJoinTable();
  virtual ~MsgJoinTable();

  MsgJoinTable(const MsgJoinTable& from);

  inline MsgJoinTable& operator=(const MsgJoinTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgJoinTable(MsgJoinTable&& from) noexcept
    : MsgJoinTable() {
    *this = ::std::move(from);
  }

  inline MsgJoinTable& operator=(MsgJoinTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgJoinTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgJoinTable* internal_default_instance() {
    return reinterpret_cast<const MsgJoinTable*>(
               &_MsgJoinTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MsgJoinTable* other);
  friend void swap(MsgJoinTable& a, MsgJoinTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgJoinTable* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgJoinTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgJoinTable& from);
  void MergeFrom(const MsgJoinTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgJoinTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 tableId = 1;
  void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  ::google::protobuf::uint32 tableid() const;
  void set_tableid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgJoinTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 tableid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgJoinTableImpl();
};
// -------------------------------------------------------------------

class MsgLeaveTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgLeaveTable) */ {
 public:
  MsgLeaveTable();
  virtual ~MsgLeaveTable();

  MsgLeaveTable(const MsgLeaveTable& from);

  inline MsgLeaveTable& operator=(const MsgLeaveTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgLeaveTable(MsgLeaveTable&& from) noexcept
    : MsgLeaveTable() {
    *this = ::std::move(from);
  }

  inline MsgLeaveTable& operator=(MsgLeaveTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLeaveTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgLeaveTable* internal_default_instance() {
    return reinterpret_cast<const MsgLeaveTable*>(
               &_MsgLeaveTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MsgLeaveTable* other);
  friend void swap(MsgLeaveTable& a, MsgLeaveTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgLeaveTable* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgLeaveTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgLeaveTable& from);
  void MergeFrom(const MsgLeaveTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgLeaveTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MsgLeaveTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgLeaveTableImpl();
};
// -------------------------------------------------------------------

class MsgRaise : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgRaise) */ {
 public:
  MsgRaise();
  virtual ~MsgRaise();

  MsgRaise(const MsgRaise& from);

  inline MsgRaise& operator=(const MsgRaise& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgRaise(MsgRaise&& from) noexcept
    : MsgRaise() {
    *this = ::std::move(from);
  }

  inline MsgRaise& operator=(MsgRaise&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgRaise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgRaise* internal_default_instance() {
    return reinterpret_cast<const MsgRaise*>(
               &_MsgRaise_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MsgRaise* other);
  friend void swap(MsgRaise& a, MsgRaise& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgRaise* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgRaise* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgRaise& from);
  void MergeFrom(const MsgRaise& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgRaise* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 chips = 1;
  void clear_chips();
  static const int kChipsFieldNumber = 1;
  ::google::protobuf::int32 chips() const;
  void set_chips(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MsgRaise)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 chips_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgRaiseImpl();
};
// -------------------------------------------------------------------

class MsgFold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgFold) */ {
 public:
  MsgFold();
  virtual ~MsgFold();

  MsgFold(const MsgFold& from);

  inline MsgFold& operator=(const MsgFold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgFold(MsgFold&& from) noexcept
    : MsgFold() {
    *this = ::std::move(from);
  }

  inline MsgFold& operator=(MsgFold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgFold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgFold* internal_default_instance() {
    return reinterpret_cast<const MsgFold*>(
               &_MsgFold_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MsgFold* other);
  friend void swap(MsgFold& a, MsgFold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgFold* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgFold* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgFold& from);
  void MergeFrom(const MsgFold& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgFold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MsgFold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgFoldImpl();
};
// -------------------------------------------------------------------

class MsgCall : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgCall) */ {
 public:
  MsgCall();
  virtual ~MsgCall();

  MsgCall(const MsgCall& from);

  inline MsgCall& operator=(const MsgCall& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgCall(MsgCall&& from) noexcept
    : MsgCall() {
    *this = ::std::move(from);
  }

  inline MsgCall& operator=(MsgCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgCall* internal_default_instance() {
    return reinterpret_cast<const MsgCall*>(
               &_MsgCall_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MsgCall* other);
  friend void swap(MsgCall& a, MsgCall& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgCall* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgCall* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgCall& from);
  void MergeFrom(const MsgCall& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MsgCall)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgCallImpl();
};
// -------------------------------------------------------------------

class MsgCard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgCard) */ {
 public:
  MsgCard();
  virtual ~MsgCard();

  MsgCard(const MsgCard& from);

  inline MsgCard& operator=(const MsgCard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgCard(MsgCard&& from) noexcept
    : MsgCard() {
    *this = ::std::move(from);
  }

  inline MsgCard& operator=(MsgCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgCard* internal_default_instance() {
    return reinterpret_cast<const MsgCard*>(
               &_MsgCard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(MsgCard* other);
  friend void swap(MsgCard& a, MsgCard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgCard* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgCard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgCard& from);
  void MergeFrom(const MsgCard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgCard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .MsgCardValue cardValue = 1;
  void clear_cardvalue();
  static const int kCardValueFieldNumber = 1;
  ::MsgCardValue cardvalue() const;
  void set_cardvalue(::MsgCardValue value);

  // .MsgCardSuit cardSuit = 2;
  void clear_cardsuit();
  static const int kCardSuitFieldNumber = 2;
  ::MsgCardSuit cardsuit() const;
  void set_cardsuit(::MsgCardSuit value);

  // @@protoc_insertion_point(class_scope:MsgCard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cardvalue_;
  int cardsuit_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgCardImpl();
};
// -------------------------------------------------------------------

class MsgPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgPlayer) */ {
 public:
  MsgPlayer();
  virtual ~MsgPlayer();

  MsgPlayer(const MsgPlayer& from);

  inline MsgPlayer& operator=(const MsgPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgPlayer(MsgPlayer&& from) noexcept
    : MsgPlayer() {
    *this = ::std::move(from);
  }

  inline MsgPlayer& operator=(MsgPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgPlayer* internal_default_instance() {
    return reinterpret_cast<const MsgPlayer*>(
               &_MsgPlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(MsgPlayer* other);
  friend void swap(MsgPlayer& a, MsgPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgPlayer* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgPlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgPlayer& from);
  void MergeFrom(const MsgPlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MsgCard hand = 3;
  int hand_size() const;
  void clear_hand();
  static const int kHandFieldNumber = 3;
  const ::MsgCard& hand(int index) const;
  ::MsgCard* mutable_hand(int index);
  ::MsgCard* add_hand();
  ::google::protobuf::RepeatedPtrField< ::MsgCard >*
      mutable_hand();
  const ::google::protobuf::RepeatedPtrField< ::MsgCard >&
      hand() const;

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // uint32 chips = 2;
  void clear_chips();
  static const int kChipsFieldNumber = 2;
  ::google::protobuf::uint32 chips() const;
  void set_chips(::google::protobuf::uint32 value);

  // bool dealer = 4;
  void clear_dealer();
  static const int kDealerFieldNumber = 4;
  bool dealer() const;
  void set_dealer(bool value);

  // @@protoc_insertion_point(class_scope:MsgPlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::MsgCard > hand_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 chips_;
  bool dealer_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgPlayerImpl();
};
// -------------------------------------------------------------------

class MsgTableInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgTableInfo) */ {
 public:
  MsgTableInfo();
  virtual ~MsgTableInfo();

  MsgTableInfo(const MsgTableInfo& from);

  inline MsgTableInfo& operator=(const MsgTableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTableInfo(MsgTableInfo&& from) noexcept
    : MsgTableInfo() {
    *this = ::std::move(from);
  }

  inline MsgTableInfo& operator=(MsgTableInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTableInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTableInfo* internal_default_instance() {
    return reinterpret_cast<const MsgTableInfo*>(
               &_MsgTableInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(MsgTableInfo* other);
  friend void swap(MsgTableInfo& a, MsgTableInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTableInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTableInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTableInfo& from);
  void MergeFrom(const MsgTableInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTableInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // uint32 maxPlayers = 3;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 3;
  ::google::protobuf::uint32 maxplayers() const;
  void set_maxplayers(::google::protobuf::uint32 value);

  // uint32 players = 4;
  void clear_players();
  static const int kPlayersFieldNumber = 4;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgTableInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 maxplayers_;
  ::google::protobuf::uint32 players_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgTableInfoImpl();
};
// -------------------------------------------------------------------

class MsgLobbyView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgLobbyView) */ {
 public:
  MsgLobbyView();
  virtual ~MsgLobbyView();

  MsgLobbyView(const MsgLobbyView& from);

  inline MsgLobbyView& operator=(const MsgLobbyView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgLobbyView(MsgLobbyView&& from) noexcept
    : MsgLobbyView() {
    *this = ::std::move(from);
  }

  inline MsgLobbyView& operator=(MsgLobbyView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgLobbyView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgLobbyView* internal_default_instance() {
    return reinterpret_cast<const MsgLobbyView*>(
               &_MsgLobbyView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(MsgLobbyView* other);
  friend void swap(MsgLobbyView& a, MsgLobbyView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgLobbyView* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgLobbyView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgLobbyView& from);
  void MergeFrom(const MsgLobbyView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgLobbyView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MsgTableInfo tables = 1;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 1;
  const ::MsgTableInfo& tables(int index) const;
  ::MsgTableInfo* mutable_tables(int index);
  ::MsgTableInfo* add_tables();
  ::google::protobuf::RepeatedPtrField< ::MsgTableInfo >*
      mutable_tables();
  const ::google::protobuf::RepeatedPtrField< ::MsgTableInfo >&
      tables() const;

  // @@protoc_insertion_point(class_scope:MsgLobbyView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::MsgTableInfo > tables_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgLobbyViewImpl();
};
// -------------------------------------------------------------------

class MsgTableView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MsgTableView) */ {
 public:
  MsgTableView();
  virtual ~MsgTableView();

  MsgTableView(const MsgTableView& from);

  inline MsgTableView& operator=(const MsgTableView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTableView(MsgTableView&& from) noexcept
    : MsgTableView() {
    *this = ::std::move(from);
  }

  inline MsgTableView& operator=(MsgTableView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTableView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTableView* internal_default_instance() {
    return reinterpret_cast<const MsgTableView*>(
               &_MsgTableView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(MsgTableView* other);
  friend void swap(MsgTableView& a, MsgTableView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTableView* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTableView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTableView& from);
  void MergeFrom(const MsgTableView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTableView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MsgCard cards = 3;
  int cards_size() const;
  void clear_cards();
  static const int kCardsFieldNumber = 3;
  const ::MsgCard& cards(int index) const;
  ::MsgCard* mutable_cards(int index);
  ::MsgCard* add_cards();
  ::google::protobuf::RepeatedPtrField< ::MsgCard >*
      mutable_cards();
  const ::google::protobuf::RepeatedPtrField< ::MsgCard >&
      cards() const;

  // repeated uint32 pots = 4;
  int pots_size() const;
  void clear_pots();
  static const int kPotsFieldNumber = 4;
  ::google::protobuf::uint32 pots(int index) const;
  void set_pots(int index, ::google::protobuf::uint32 value);
  void add_pots(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pots() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pots();

  // repeated .MsgPlayer players = 5;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 5;
  const ::MsgPlayer& players(int index) const;
  ::MsgPlayer* mutable_players(int index);
  ::MsgPlayer* add_players();
  ::google::protobuf::RepeatedPtrField< ::MsgPlayer >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::MsgPlayer >&
      players() const;

  // .MsgTableStatus tableStatus = 1;
  void clear_tablestatus();
  static const int kTableStatusFieldNumber = 1;
  ::MsgTableStatus tablestatus() const;
  void set_tablestatus(::MsgTableStatus value);

  // .MsgRoundStatus roundStatus = 2;
  void clear_roundstatus();
  static const int kRoundStatusFieldNumber = 2;
  ::MsgRoundStatus roundstatus() const;
  void set_roundstatus(::MsgRoundStatus value);

  // @@protoc_insertion_point(class_scope:MsgTableView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::MsgCard > cards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pots_;
  mutable int _pots_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::MsgPlayer > players_;
  int tablestatus_;
  int roundstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsMsgTableViewImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// .MsgLogin login = 1;
inline bool Request::has_login() const {
  return payload_case() == kLogin;
}
inline void Request::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void Request::clear_login() {
  if (has_login()) {
    delete payload_.login_;
    clear_has_payload();
  }
}
inline ::MsgLogin* Request::release_login() {
  // @@protoc_insertion_point(field_release:Request.login)
  if (has_login()) {
    clear_has_payload();
      ::MsgLogin* temp = payload_.login_;
    payload_.login_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgLogin& Request::login() const {
  // @@protoc_insertion_point(field_get:Request.login)
  return has_login()
      ? *payload_.login_
      : *reinterpret_cast< ::MsgLogin*>(&::_MsgLogin_default_instance_);
}
inline ::MsgLogin* Request::mutable_login() {
  if (!has_login()) {
    clear_payload();
    set_has_login();
    payload_.login_ = new ::MsgLogin;
  }
  // @@protoc_insertion_point(field_mutable:Request.login)
  return payload_.login_;
}

// .MsgJoinTable joinTable = 2;
inline bool Request::has_jointable() const {
  return payload_case() == kJoinTable;
}
inline void Request::set_has_jointable() {
  _oneof_case_[0] = kJoinTable;
}
inline void Request::clear_jointable() {
  if (has_jointable()) {
    delete payload_.jointable_;
    clear_has_payload();
  }
}
inline ::MsgJoinTable* Request::release_jointable() {
  // @@protoc_insertion_point(field_release:Request.joinTable)
  if (has_jointable()) {
    clear_has_payload();
      ::MsgJoinTable* temp = payload_.jointable_;
    payload_.jointable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgJoinTable& Request::jointable() const {
  // @@protoc_insertion_point(field_get:Request.joinTable)
  return has_jointable()
      ? *payload_.jointable_
      : *reinterpret_cast< ::MsgJoinTable*>(&::_MsgJoinTable_default_instance_);
}
inline ::MsgJoinTable* Request::mutable_jointable() {
  if (!has_jointable()) {
    clear_payload();
    set_has_jointable();
    payload_.jointable_ = new ::MsgJoinTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.joinTable)
  return payload_.jointable_;
}

// .MsgLeaveTable leaveTable = 3;
inline bool Request::has_leavetable() const {
  return payload_case() == kLeaveTable;
}
inline void Request::set_has_leavetable() {
  _oneof_case_[0] = kLeaveTable;
}
inline void Request::clear_leavetable() {
  if (has_leavetable()) {
    delete payload_.leavetable_;
    clear_has_payload();
  }
}
inline ::MsgLeaveTable* Request::release_leavetable() {
  // @@protoc_insertion_point(field_release:Request.leaveTable)
  if (has_leavetable()) {
    clear_has_payload();
      ::MsgLeaveTable* temp = payload_.leavetable_;
    payload_.leavetable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgLeaveTable& Request::leavetable() const {
  // @@protoc_insertion_point(field_get:Request.leaveTable)
  return has_leavetable()
      ? *payload_.leavetable_
      : *reinterpret_cast< ::MsgLeaveTable*>(&::_MsgLeaveTable_default_instance_);
}
inline ::MsgLeaveTable* Request::mutable_leavetable() {
  if (!has_leavetable()) {
    clear_payload();
    set_has_leavetable();
    payload_.leavetable_ = new ::MsgLeaveTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.leaveTable)
  return payload_.leavetable_;
}

// .MsgRaise raise = 4;
inline bool Request::has_raise() const {
  return payload_case() == kRaise;
}
inline void Request::set_has_raise() {
  _oneof_case_[0] = kRaise;
}
inline void Request::clear_raise() {
  if (has_raise()) {
    delete payload_.raise_;
    clear_has_payload();
  }
}
inline ::MsgRaise* Request::release_raise() {
  // @@protoc_insertion_point(field_release:Request.raise)
  if (has_raise()) {
    clear_has_payload();
      ::MsgRaise* temp = payload_.raise_;
    payload_.raise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgRaise& Request::raise() const {
  // @@protoc_insertion_point(field_get:Request.raise)
  return has_raise()
      ? *payload_.raise_
      : *reinterpret_cast< ::MsgRaise*>(&::_MsgRaise_default_instance_);
}
inline ::MsgRaise* Request::mutable_raise() {
  if (!has_raise()) {
    clear_payload();
    set_has_raise();
    payload_.raise_ = new ::MsgRaise;
  }
  // @@protoc_insertion_point(field_mutable:Request.raise)
  return payload_.raise_;
}

// .MsgFold fold = 5;
inline bool Request::has_fold() const {
  return payload_case() == kFold;
}
inline void Request::set_has_fold() {
  _oneof_case_[0] = kFold;
}
inline void Request::clear_fold() {
  if (has_fold()) {
    delete payload_.fold_;
    clear_has_payload();
  }
}
inline ::MsgFold* Request::release_fold() {
  // @@protoc_insertion_point(field_release:Request.fold)
  if (has_fold()) {
    clear_has_payload();
      ::MsgFold* temp = payload_.fold_;
    payload_.fold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgFold& Request::fold() const {
  // @@protoc_insertion_point(field_get:Request.fold)
  return has_fold()
      ? *payload_.fold_
      : *reinterpret_cast< ::MsgFold*>(&::_MsgFold_default_instance_);
}
inline ::MsgFold* Request::mutable_fold() {
  if (!has_fold()) {
    clear_payload();
    set_has_fold();
    payload_.fold_ = new ::MsgFold;
  }
  // @@protoc_insertion_point(field_mutable:Request.fold)
  return payload_.fold_;
}

// .MsgCall call = 6;
inline bool Request::has_call() const {
  return payload_case() == kCall;
}
inline void Request::set_has_call() {
  _oneof_case_[0] = kCall;
}
inline void Request::clear_call() {
  if (has_call()) {
    delete payload_.call_;
    clear_has_payload();
  }
}
inline ::MsgCall* Request::release_call() {
  // @@protoc_insertion_point(field_release:Request.call)
  if (has_call()) {
    clear_has_payload();
      ::MsgCall* temp = payload_.call_;
    payload_.call_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgCall& Request::call() const {
  // @@protoc_insertion_point(field_get:Request.call)
  return has_call()
      ? *payload_.call_
      : *reinterpret_cast< ::MsgCall*>(&::_MsgCall_default_instance_);
}
inline ::MsgCall* Request::mutable_call() {
  if (!has_call()) {
    clear_payload();
    set_has_call();
    payload_.call_ = new ::MsgCall;
  }
  // @@protoc_insertion_point(field_mutable:Request.call)
  return payload_.call_;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .MsgError error = 1;
inline void Response::clear_error() {
  error_ = 0;
}
inline ::MsgError Response::error() const {
  // @@protoc_insertion_point(field_get:Response.error)
  return static_cast< ::MsgError >(error_);
}
inline void Response::set_error(::MsgError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:Response.error)
}

// .MsgLobbyView lobbyView = 2;
inline bool Response::has_lobbyview() const {
  return payload_case() == kLobbyView;
}
inline void Response::set_has_lobbyview() {
  _oneof_case_[0] = kLobbyView;
}
inline void Response::clear_lobbyview() {
  if (has_lobbyview()) {
    delete payload_.lobbyview_;
    clear_has_payload();
  }
}
inline ::MsgLobbyView* Response::release_lobbyview() {
  // @@protoc_insertion_point(field_release:Response.lobbyView)
  if (has_lobbyview()) {
    clear_has_payload();
      ::MsgLobbyView* temp = payload_.lobbyview_;
    payload_.lobbyview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgLobbyView& Response::lobbyview() const {
  // @@protoc_insertion_point(field_get:Response.lobbyView)
  return has_lobbyview()
      ? *payload_.lobbyview_
      : *reinterpret_cast< ::MsgLobbyView*>(&::_MsgLobbyView_default_instance_);
}
inline ::MsgLobbyView* Response::mutable_lobbyview() {
  if (!has_lobbyview()) {
    clear_payload();
    set_has_lobbyview();
    payload_.lobbyview_ = new ::MsgLobbyView;
  }
  // @@protoc_insertion_point(field_mutable:Response.lobbyView)
  return payload_.lobbyview_;
}

// .MsgTableView tableView = 3;
inline bool Response::has_tableview() const {
  return payload_case() == kTableView;
}
inline void Response::set_has_tableview() {
  _oneof_case_[0] = kTableView;
}
inline void Response::clear_tableview() {
  if (has_tableview()) {
    delete payload_.tableview_;
    clear_has_payload();
  }
}
inline ::MsgTableView* Response::release_tableview() {
  // @@protoc_insertion_point(field_release:Response.tableView)
  if (has_tableview()) {
    clear_has_payload();
      ::MsgTableView* temp = payload_.tableview_;
    payload_.tableview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MsgTableView& Response::tableview() const {
  // @@protoc_insertion_point(field_get:Response.tableView)
  return has_tableview()
      ? *payload_.tableview_
      : *reinterpret_cast< ::MsgTableView*>(&::_MsgTableView_default_instance_);
}
inline ::MsgTableView* Response::mutable_tableview() {
  if (!has_tableview()) {
    clear_payload();
    set_has_tableview();
    payload_.tableview_ = new ::MsgTableView;
  }
  // @@protoc_insertion_point(field_mutable:Response.tableView)
  return payload_.tableview_;
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MsgLogin

// string username = 1;
inline void MsgLogin::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgLogin::username() const {
  // @@protoc_insertion_point(field_get:MsgLogin.username)
  return username_.GetNoArena();
}
inline void MsgLogin::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MsgLogin.username)
}
#if LANG_CXX11
inline void MsgLogin::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MsgLogin.username)
}
#endif
inline void MsgLogin::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MsgLogin.username)
}
inline void MsgLogin::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MsgLogin.username)
}
inline ::std::string* MsgLogin::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:MsgLogin.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgLogin::release_username() {
  // @@protoc_insertion_point(field_release:MsgLogin.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgLogin::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:MsgLogin.username)
}

// -------------------------------------------------------------------

// MsgJoinTable

// uint32 tableId = 1;
inline void MsgJoinTable::clear_tableid() {
  tableid_ = 0u;
}
inline ::google::protobuf::uint32 MsgJoinTable::tableid() const {
  // @@protoc_insertion_point(field_get:MsgJoinTable.tableId)
  return tableid_;
}
inline void MsgJoinTable::set_tableid(::google::protobuf::uint32 value) {
  
  tableid_ = value;
  // @@protoc_insertion_point(field_set:MsgJoinTable.tableId)
}

// -------------------------------------------------------------------

// MsgLeaveTable

// -------------------------------------------------------------------

// MsgRaise

// int32 chips = 1;
inline void MsgRaise::clear_chips() {
  chips_ = 0;
}
inline ::google::protobuf::int32 MsgRaise::chips() const {
  // @@protoc_insertion_point(field_get:MsgRaise.chips)
  return chips_;
}
inline void MsgRaise::set_chips(::google::protobuf::int32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:MsgRaise.chips)
}

// -------------------------------------------------------------------

// MsgFold

// -------------------------------------------------------------------

// MsgCall

// -------------------------------------------------------------------

// MsgCard

// .MsgCardValue cardValue = 1;
inline void MsgCard::clear_cardvalue() {
  cardvalue_ = 0;
}
inline ::MsgCardValue MsgCard::cardvalue() const {
  // @@protoc_insertion_point(field_get:MsgCard.cardValue)
  return static_cast< ::MsgCardValue >(cardvalue_);
}
inline void MsgCard::set_cardvalue(::MsgCardValue value) {
  
  cardvalue_ = value;
  // @@protoc_insertion_point(field_set:MsgCard.cardValue)
}

// .MsgCardSuit cardSuit = 2;
inline void MsgCard::clear_cardsuit() {
  cardsuit_ = 0;
}
inline ::MsgCardSuit MsgCard::cardsuit() const {
  // @@protoc_insertion_point(field_get:MsgCard.cardSuit)
  return static_cast< ::MsgCardSuit >(cardsuit_);
}
inline void MsgCard::set_cardsuit(::MsgCardSuit value) {
  
  cardsuit_ = value;
  // @@protoc_insertion_point(field_set:MsgCard.cardSuit)
}

// -------------------------------------------------------------------

// MsgPlayer

// string username = 1;
inline void MsgPlayer::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgPlayer::username() const {
  // @@protoc_insertion_point(field_get:MsgPlayer.username)
  return username_.GetNoArena();
}
inline void MsgPlayer::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MsgPlayer.username)
}
#if LANG_CXX11
inline void MsgPlayer::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MsgPlayer.username)
}
#endif
inline void MsgPlayer::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MsgPlayer.username)
}
inline void MsgPlayer::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MsgPlayer.username)
}
inline ::std::string* MsgPlayer::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:MsgPlayer.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgPlayer::release_username() {
  // @@protoc_insertion_point(field_release:MsgPlayer.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgPlayer::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:MsgPlayer.username)
}

// uint32 chips = 2;
inline void MsgPlayer::clear_chips() {
  chips_ = 0u;
}
inline ::google::protobuf::uint32 MsgPlayer::chips() const {
  // @@protoc_insertion_point(field_get:MsgPlayer.chips)
  return chips_;
}
inline void MsgPlayer::set_chips(::google::protobuf::uint32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:MsgPlayer.chips)
}

// repeated .MsgCard hand = 3;
inline int MsgPlayer::hand_size() const {
  return hand_.size();
}
inline void MsgPlayer::clear_hand() {
  hand_.Clear();
}
inline const ::MsgCard& MsgPlayer::hand(int index) const {
  // @@protoc_insertion_point(field_get:MsgPlayer.hand)
  return hand_.Get(index);
}
inline ::MsgCard* MsgPlayer::mutable_hand(int index) {
  // @@protoc_insertion_point(field_mutable:MsgPlayer.hand)
  return hand_.Mutable(index);
}
inline ::MsgCard* MsgPlayer::add_hand() {
  // @@protoc_insertion_point(field_add:MsgPlayer.hand)
  return hand_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MsgCard >*
MsgPlayer::mutable_hand() {
  // @@protoc_insertion_point(field_mutable_list:MsgPlayer.hand)
  return &hand_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgCard >&
MsgPlayer::hand() const {
  // @@protoc_insertion_point(field_list:MsgPlayer.hand)
  return hand_;
}

// bool dealer = 4;
inline void MsgPlayer::clear_dealer() {
  dealer_ = false;
}
inline bool MsgPlayer::dealer() const {
  // @@protoc_insertion_point(field_get:MsgPlayer.dealer)
  return dealer_;
}
inline void MsgPlayer::set_dealer(bool value) {
  
  dealer_ = value;
  // @@protoc_insertion_point(field_set:MsgPlayer.dealer)
}

// -------------------------------------------------------------------

// MsgTableInfo

// uint32 index = 1;
inline void MsgTableInfo::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 MsgTableInfo::index() const {
  // @@protoc_insertion_point(field_get:MsgTableInfo.index)
  return index_;
}
inline void MsgTableInfo::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:MsgTableInfo.index)
}

// string name = 2;
inline void MsgTableInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgTableInfo::name() const {
  // @@protoc_insertion_point(field_get:MsgTableInfo.name)
  return name_.GetNoArena();
}
inline void MsgTableInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MsgTableInfo.name)
}
#if LANG_CXX11
inline void MsgTableInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MsgTableInfo.name)
}
#endif
inline void MsgTableInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MsgTableInfo.name)
}
inline void MsgTableInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MsgTableInfo.name)
}
inline ::std::string* MsgTableInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:MsgTableInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgTableInfo::release_name() {
  // @@protoc_insertion_point(field_release:MsgTableInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgTableInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MsgTableInfo.name)
}

// uint32 maxPlayers = 3;
inline void MsgTableInfo::clear_maxplayers() {
  maxplayers_ = 0u;
}
inline ::google::protobuf::uint32 MsgTableInfo::maxplayers() const {
  // @@protoc_insertion_point(field_get:MsgTableInfo.maxPlayers)
  return maxplayers_;
}
inline void MsgTableInfo::set_maxplayers(::google::protobuf::uint32 value) {
  
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:MsgTableInfo.maxPlayers)
}

// uint32 players = 4;
inline void MsgTableInfo::clear_players() {
  players_ = 0u;
}
inline ::google::protobuf::uint32 MsgTableInfo::players() const {
  // @@protoc_insertion_point(field_get:MsgTableInfo.players)
  return players_;
}
inline void MsgTableInfo::set_players(::google::protobuf::uint32 value) {
  
  players_ = value;
  // @@protoc_insertion_point(field_set:MsgTableInfo.players)
}

// -------------------------------------------------------------------

// MsgLobbyView

// repeated .MsgTableInfo tables = 1;
inline int MsgLobbyView::tables_size() const {
  return tables_.size();
}
inline void MsgLobbyView::clear_tables() {
  tables_.Clear();
}
inline const ::MsgTableInfo& MsgLobbyView::tables(int index) const {
  // @@protoc_insertion_point(field_get:MsgLobbyView.tables)
  return tables_.Get(index);
}
inline ::MsgTableInfo* MsgLobbyView::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:MsgLobbyView.tables)
  return tables_.Mutable(index);
}
inline ::MsgTableInfo* MsgLobbyView::add_tables() {
  // @@protoc_insertion_point(field_add:MsgLobbyView.tables)
  return tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MsgTableInfo >*
MsgLobbyView::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:MsgLobbyView.tables)
  return &tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgTableInfo >&
MsgLobbyView::tables() const {
  // @@protoc_insertion_point(field_list:MsgLobbyView.tables)
  return tables_;
}

// -------------------------------------------------------------------

// MsgTableView

// .MsgTableStatus tableStatus = 1;
inline void MsgTableView::clear_tablestatus() {
  tablestatus_ = 0;
}
inline ::MsgTableStatus MsgTableView::tablestatus() const {
  // @@protoc_insertion_point(field_get:MsgTableView.tableStatus)
  return static_cast< ::MsgTableStatus >(tablestatus_);
}
inline void MsgTableView::set_tablestatus(::MsgTableStatus value) {
  
  tablestatus_ = value;
  // @@protoc_insertion_point(field_set:MsgTableView.tableStatus)
}

// .MsgRoundStatus roundStatus = 2;
inline void MsgTableView::clear_roundstatus() {
  roundstatus_ = 0;
}
inline ::MsgRoundStatus MsgTableView::roundstatus() const {
  // @@protoc_insertion_point(field_get:MsgTableView.roundStatus)
  return static_cast< ::MsgRoundStatus >(roundstatus_);
}
inline void MsgTableView::set_roundstatus(::MsgRoundStatus value) {
  
  roundstatus_ = value;
  // @@protoc_insertion_point(field_set:MsgTableView.roundStatus)
}

// repeated .MsgCard cards = 3;
inline int MsgTableView::cards_size() const {
  return cards_.size();
}
inline void MsgTableView::clear_cards() {
  cards_.Clear();
}
inline const ::MsgCard& MsgTableView::cards(int index) const {
  // @@protoc_insertion_point(field_get:MsgTableView.cards)
  return cards_.Get(index);
}
inline ::MsgCard* MsgTableView::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:MsgTableView.cards)
  return cards_.Mutable(index);
}
inline ::MsgCard* MsgTableView::add_cards() {
  // @@protoc_insertion_point(field_add:MsgTableView.cards)
  return cards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MsgCard >*
MsgTableView::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:MsgTableView.cards)
  return &cards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgCard >&
MsgTableView::cards() const {
  // @@protoc_insertion_point(field_list:MsgTableView.cards)
  return cards_;
}

// repeated uint32 pots = 4;
inline int MsgTableView::pots_size() const {
  return pots_.size();
}
inline void MsgTableView::clear_pots() {
  pots_.Clear();
}
inline ::google::protobuf::uint32 MsgTableView::pots(int index) const {
  // @@protoc_insertion_point(field_get:MsgTableView.pots)
  return pots_.Get(index);
}
inline void MsgTableView::set_pots(int index, ::google::protobuf::uint32 value) {
  pots_.Set(index, value);
  // @@protoc_insertion_point(field_set:MsgTableView.pots)
}
inline void MsgTableView::add_pots(::google::protobuf::uint32 value) {
  pots_.Add(value);
  // @@protoc_insertion_point(field_add:MsgTableView.pots)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MsgTableView::pots() const {
  // @@protoc_insertion_point(field_list:MsgTableView.pots)
  return pots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MsgTableView::mutable_pots() {
  // @@protoc_insertion_point(field_mutable_list:MsgTableView.pots)
  return &pots_;
}

// repeated .MsgPlayer players = 5;
inline int MsgTableView::players_size() const {
  return players_.size();
}
inline void MsgTableView::clear_players() {
  players_.Clear();
}
inline const ::MsgPlayer& MsgTableView::players(int index) const {
  // @@protoc_insertion_point(field_get:MsgTableView.players)
  return players_.Get(index);
}
inline ::MsgPlayer* MsgTableView::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MsgTableView.players)
  return players_.Mutable(index);
}
inline ::MsgPlayer* MsgTableView::add_players() {
  // @@protoc_insertion_point(field_add:MsgTableView.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MsgPlayer >*
MsgTableView::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MsgTableView.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgPlayer >&
MsgTableView::players() const {
  // @@protoc_insertion_point(field_list:MsgTableView.players)
  return players_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MsgError> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgError>() {
  return ::MsgError_descriptor();
}
template <> struct is_proto_enum< ::MsgTableStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgTableStatus>() {
  return ::MsgTableStatus_descriptor();
}
template <> struct is_proto_enum< ::MsgRoundStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgRoundStatus>() {
  return ::MsgRoundStatus_descriptor();
}
template <> struct is_proto_enum< ::MsgCardValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgCardValue>() {
  return ::MsgCardValue_descriptor();
}
template <> struct is_proto_enum< ::MsgCardSuit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgCardSuit>() {
  return ::MsgCardSuit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protocol_2eproto__INCLUDED
