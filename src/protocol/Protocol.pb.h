// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef PROTOBUF_Protocol_2eproto__INCLUDED
#define PROTOBUF_Protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
void InitDefaultsCreateTableImpl();
void InitDefaultsCreateTable();
void InitDefaultsJoinTableImpl();
void InitDefaultsJoinTable();
void InitDefaultsLeaveTableImpl();
void InitDefaultsLeaveTable();
void InitDefaultsRaiseImpl();
void InitDefaultsRaise();
void InitDefaultsFoldImpl();
void InitDefaultsFold();
void InitDefaultsCallImpl();
void InitDefaultsCall();
void InitDefaultsDummyCardImpl();
void InitDefaultsDummyCard();
void InitDefaultsDummyPlayerImpl();
void InitDefaultsDummyPlayer();
void InitDefaultsDummyTableInfoImpl();
void InitDefaultsDummyTableInfo();
void InitDefaultsDummyLobbyViewImpl();
void InitDefaultsDummyLobbyView();
void InitDefaultsDummyTableViewImpl();
void InitDefaultsDummyTableView();
inline void InitDefaults() {
  InitDefaultsRequest();
  InitDefaultsResponse();
  InitDefaultsLogin();
  InitDefaultsCreateTable();
  InitDefaultsJoinTable();
  InitDefaultsLeaveTable();
  InitDefaultsRaise();
  InitDefaultsFold();
  InitDefaultsCall();
  InitDefaultsDummyCard();
  InitDefaultsDummyPlayer();
  InitDefaultsDummyTableInfo();
  InitDefaultsDummyLobbyView();
  InitDefaultsDummyTableView();
}
}  // namespace protobuf_Protocol_2eproto
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class CreateTable;
class CreateTableDefaultTypeInternal;
extern CreateTableDefaultTypeInternal _CreateTable_default_instance_;
class DummyCard;
class DummyCardDefaultTypeInternal;
extern DummyCardDefaultTypeInternal _DummyCard_default_instance_;
class DummyLobbyView;
class DummyLobbyViewDefaultTypeInternal;
extern DummyLobbyViewDefaultTypeInternal _DummyLobbyView_default_instance_;
class DummyPlayer;
class DummyPlayerDefaultTypeInternal;
extern DummyPlayerDefaultTypeInternal _DummyPlayer_default_instance_;
class DummyTableInfo;
class DummyTableInfoDefaultTypeInternal;
extern DummyTableInfoDefaultTypeInternal _DummyTableInfo_default_instance_;
class DummyTableView;
class DummyTableViewDefaultTypeInternal;
extern DummyTableViewDefaultTypeInternal _DummyTableView_default_instance_;
class Fold;
class FoldDefaultTypeInternal;
extern FoldDefaultTypeInternal _Fold_default_instance_;
class JoinTable;
class JoinTableDefaultTypeInternal;
extern JoinTableDefaultTypeInternal _JoinTable_default_instance_;
class LeaveTable;
class LeaveTableDefaultTypeInternal;
extern LeaveTableDefaultTypeInternal _LeaveTable_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Raise;
class RaiseDefaultTypeInternal;
extern RaiseDefaultTypeInternal _Raise_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;

enum Error {
  ErrorSuccess = 0,
  ErrorWrongMessage = 1,
  ErrorInvalidValue = 2,
  Error_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Error_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Error_IsValid(int value);
const Error Error_MIN = ErrorSuccess;
const Error Error_MAX = ErrorInvalidValue;
const int Error_ARRAYSIZE = Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_descriptor();
inline const ::std::string& Error_Name(Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_descriptor(), value);
}
inline bool Error_Parse(
    const ::std::string& name, Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error>(
    Error_descriptor(), name, value);
}
enum DummyTableStatus {
  DummyTableStatusUnknown = 0,
  DummyTableStatusWaitingForPlayers = 1,
  DummyTableStatusGameInProgress = 2,
  DummyTableStatusGameEnded = 3,
  DummyTableStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DummyTableStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DummyTableStatus_IsValid(int value);
const DummyTableStatus DummyTableStatus_MIN = DummyTableStatusUnknown;
const DummyTableStatus DummyTableStatus_MAX = DummyTableStatusGameEnded;
const int DummyTableStatus_ARRAYSIZE = DummyTableStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* DummyTableStatus_descriptor();
inline const ::std::string& DummyTableStatus_Name(DummyTableStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    DummyTableStatus_descriptor(), value);
}
inline bool DummyTableStatus_Parse(
    const ::std::string& name, DummyTableStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DummyTableStatus>(
    DummyTableStatus_descriptor(), name, value);
}
enum DummyRoundStatus {
  DummyRoundStatusUnknown = 0,
  DummyRoundStatusPreFlop = 1,
  DummyRoundStatusFlop = 2,
  DummyRoundStatusTurn = 3,
  DummyRoundStatusRiver = 4,
  DummyRoundStatusEnd = 5,
  DummyRoundStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DummyRoundStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DummyRoundStatus_IsValid(int value);
const DummyRoundStatus DummyRoundStatus_MIN = DummyRoundStatusUnknown;
const DummyRoundStatus DummyRoundStatus_MAX = DummyRoundStatusEnd;
const int DummyRoundStatus_ARRAYSIZE = DummyRoundStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* DummyRoundStatus_descriptor();
inline const ::std::string& DummyRoundStatus_Name(DummyRoundStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    DummyRoundStatus_descriptor(), value);
}
inline bool DummyRoundStatus_Parse(
    const ::std::string& name, DummyRoundStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DummyRoundStatus>(
    DummyRoundStatus_descriptor(), name, value);
}
enum DummyCardValue {
  DummyCardValueUnkown = 0,
  DummyCardValueTwo = 2,
  DummyCardValueThree = 3,
  DummyCardValueFour = 4,
  DummyCardValueFive = 5,
  DummyCardValueSix = 6,
  DummyCardValueSeven = 7,
  DummyCardValueEight = 8,
  DummyCardValueNine = 9,
  DummyCardValueTen = 10,
  DummyCardValueJack = 11,
  DummyCardValueQueen = 12,
  DummyCardValueKing = 13,
  DummyCardValueAce = 14,
  DummyCardValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DummyCardValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DummyCardValue_IsValid(int value);
const DummyCardValue DummyCardValue_MIN = DummyCardValueUnkown;
const DummyCardValue DummyCardValue_MAX = DummyCardValueAce;
const int DummyCardValue_ARRAYSIZE = DummyCardValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* DummyCardValue_descriptor();
inline const ::std::string& DummyCardValue_Name(DummyCardValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    DummyCardValue_descriptor(), value);
}
inline bool DummyCardValue_Parse(
    const ::std::string& name, DummyCardValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DummyCardValue>(
    DummyCardValue_descriptor(), name, value);
}
enum DummyCardSuit {
  DummyCardSuitUnkown = 0,
  DummyCardSuitSpades = 1,
  DummyCardSuitHearts = 2,
  DummyCardSuitDiamonds = 3,
  DummyCardSuitClubs = 4,
  DummyCardSuit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DummyCardSuit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DummyCardSuit_IsValid(int value);
const DummyCardSuit DummyCardSuit_MIN = DummyCardSuitUnkown;
const DummyCardSuit DummyCardSuit_MAX = DummyCardSuitClubs;
const int DummyCardSuit_ARRAYSIZE = DummyCardSuit_MAX + 1;

const ::google::protobuf::EnumDescriptor* DummyCardSuit_descriptor();
inline const ::std::string& DummyCardSuit_Name(DummyCardSuit value) {
  return ::google::protobuf::internal::NameOfEnum(
    DummyCardSuit_descriptor(), value);
}
inline bool DummyCardSuit_Parse(
    const ::std::string& name, DummyCardSuit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DummyCardSuit>(
    DummyCardSuit_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum PayloadCase {
    kLogin = 1,
    kCreateTable = 2,
    kJoinTable = 3,
    kLeaveTable = 4,
    kRaise = 5,
    kFold = 6,
    kCall = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Login login = 1;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::Login& login() const;
  ::Login* release_login();
  ::Login* mutable_login();
  void set_allocated_login(::Login* login);

  // .CreateTable createTable = 2;
  bool has_createtable() const;
  void clear_createtable();
  static const int kCreateTableFieldNumber = 2;
  const ::CreateTable& createtable() const;
  ::CreateTable* release_createtable();
  ::CreateTable* mutable_createtable();
  void set_allocated_createtable(::CreateTable* createtable);

  // .JoinTable joinTable = 3;
  bool has_jointable() const;
  void clear_jointable();
  static const int kJoinTableFieldNumber = 3;
  const ::JoinTable& jointable() const;
  ::JoinTable* release_jointable();
  ::JoinTable* mutable_jointable();
  void set_allocated_jointable(::JoinTable* jointable);

  // .LeaveTable leaveTable = 4;
  bool has_leavetable() const;
  void clear_leavetable();
  static const int kLeaveTableFieldNumber = 4;
  const ::LeaveTable& leavetable() const;
  ::LeaveTable* release_leavetable();
  ::LeaveTable* mutable_leavetable();
  void set_allocated_leavetable(::LeaveTable* leavetable);

  // .Raise raise = 5;
  bool has_raise() const;
  void clear_raise();
  static const int kRaiseFieldNumber = 5;
  const ::Raise& raise() const;
  ::Raise* release_raise();
  ::Raise* mutable_raise();
  void set_allocated_raise(::Raise* raise);

  // .Fold fold = 6;
  bool has_fold() const;
  void clear_fold();
  static const int kFoldFieldNumber = 6;
  const ::Fold& fold() const;
  ::Fold* release_fold();
  ::Fold* mutable_fold();
  void set_allocated_fold(::Fold* fold);

  // .Call call = 7;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 7;
  const ::Call& call() const;
  ::Call* release_call();
  ::Call* mutable_call();
  void set_allocated_call(::Call* call);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Request)
 private:
  void set_has_login();
  void set_has_createtable();
  void set_has_jointable();
  void set_has_leavetable();
  void set_has_raise();
  void set_has_fold();
  void set_has_call();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::Login* login_;
    ::CreateTable* createtable_;
    ::JoinTable* jointable_;
    ::LeaveTable* leavetable_;
    ::Raise* raise_;
    ::Fold* fold_;
    ::Call* call_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum PayloadCase {
    kLobbyView = 2,
    kTableView = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Error error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Error error() const;
  void set_error(::Error value);

  // .DummyLobbyView lobbyView = 2;
  bool has_lobbyview() const;
  void clear_lobbyview();
  static const int kLobbyViewFieldNumber = 2;
  const ::DummyLobbyView& lobbyview() const;
  ::DummyLobbyView* release_lobbyview();
  ::DummyLobbyView* mutable_lobbyview();
  void set_allocated_lobbyview(::DummyLobbyView* lobbyview);

  // .DummyTableView tableView = 3;
  bool has_tableview() const;
  void clear_tableview();
  static const int kTableViewFieldNumber = 3;
  const ::DummyTableView& tableview() const;
  ::DummyTableView* release_tableview();
  ::DummyTableView* mutable_tableview();
  void set_allocated_tableview(::DummyTableView* tableview);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Response)
 private:
  void set_has_lobbyview();
  void set_has_tableview();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_;
  union PayloadUnion {
    PayloadUnion() {}
    ::DummyLobbyView* lobbyview_;
    ::DummyTableView* tableview_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsLoginImpl();
};
// -------------------------------------------------------------------

class CreateTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CreateTable) */ {
 public:
  CreateTable();
  virtual ~CreateTable();

  CreateTable(const CreateTable& from);

  inline CreateTable& operator=(const CreateTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTable(CreateTable&& from) noexcept
    : CreateTable() {
    *this = ::std::move(from);
  }

  inline CreateTable& operator=(CreateTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTable* internal_default_instance() {
    return reinterpret_cast<const CreateTable*>(
               &_CreateTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CreateTable* other);
  friend void swap(CreateTable& a, CreateTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTable* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateTable& from);
  void MergeFrom(const CreateTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 maxPlayers = 2;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 2;
  ::google::protobuf::uint32 maxplayers() const;
  void set_maxplayers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CreateTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 maxplayers_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsCreateTableImpl();
};
// -------------------------------------------------------------------

class JoinTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinTable) */ {
 public:
  JoinTable();
  virtual ~JoinTable();

  JoinTable(const JoinTable& from);

  inline JoinTable& operator=(const JoinTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinTable(JoinTable&& from) noexcept
    : JoinTable() {
    *this = ::std::move(from);
  }

  inline JoinTable& operator=(JoinTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinTable* internal_default_instance() {
    return reinterpret_cast<const JoinTable*>(
               &_JoinTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(JoinTable* other);
  friend void swap(JoinTable& a, JoinTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinTable* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinTable& from);
  void MergeFrom(const JoinTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:JoinTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsJoinTableImpl();
};
// -------------------------------------------------------------------

class LeaveTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeaveTable) */ {
 public:
  LeaveTable();
  virtual ~LeaveTable();

  LeaveTable(const LeaveTable& from);

  inline LeaveTable& operator=(const LeaveTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveTable(LeaveTable&& from) noexcept
    : LeaveTable() {
    *this = ::std::move(from);
  }

  inline LeaveTable& operator=(LeaveTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveTable* internal_default_instance() {
    return reinterpret_cast<const LeaveTable*>(
               &_LeaveTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LeaveTable* other);
  friend void swap(LeaveTable& a, LeaveTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveTable* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveTable& from);
  void MergeFrom(const LeaveTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:LeaveTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsLeaveTableImpl();
};
// -------------------------------------------------------------------

class Raise : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Raise) */ {
 public:
  Raise();
  virtual ~Raise();

  Raise(const Raise& from);

  inline Raise& operator=(const Raise& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Raise(Raise&& from) noexcept
    : Raise() {
    *this = ::std::move(from);
  }

  inline Raise& operator=(Raise&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Raise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Raise* internal_default_instance() {
    return reinterpret_cast<const Raise*>(
               &_Raise_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Raise* other);
  friend void swap(Raise& a, Raise& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Raise* New() const PROTOBUF_FINAL { return New(NULL); }

  Raise* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Raise& from);
  void MergeFrom(const Raise& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Raise* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 chips = 1;
  void clear_chips();
  static const int kChipsFieldNumber = 1;
  ::google::protobuf::int32 chips() const;
  void set_chips(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Raise)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 chips_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsRaiseImpl();
};
// -------------------------------------------------------------------

class Fold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Fold) */ {
 public:
  Fold();
  virtual ~Fold();

  Fold(const Fold& from);

  inline Fold& operator=(const Fold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fold(Fold&& from) noexcept
    : Fold() {
    *this = ::std::move(from);
  }

  inline Fold& operator=(Fold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fold* internal_default_instance() {
    return reinterpret_cast<const Fold*>(
               &_Fold_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Fold* other);
  friend void swap(Fold& a, Fold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fold* New() const PROTOBUF_FINAL { return New(NULL); }

  Fold* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fold& from);
  void MergeFrom(const Fold& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Fold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsFoldImpl();
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Call)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsCallImpl();
};
// -------------------------------------------------------------------

class DummyCard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DummyCard) */ {
 public:
  DummyCard();
  virtual ~DummyCard();

  DummyCard(const DummyCard& from);

  inline DummyCard& operator=(const DummyCard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DummyCard(DummyCard&& from) noexcept
    : DummyCard() {
    *this = ::std::move(from);
  }

  inline DummyCard& operator=(DummyCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DummyCard* internal_default_instance() {
    return reinterpret_cast<const DummyCard*>(
               &_DummyCard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DummyCard* other);
  friend void swap(DummyCard& a, DummyCard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DummyCard* New() const PROTOBUF_FINAL { return New(NULL); }

  DummyCard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DummyCard& from);
  void MergeFrom(const DummyCard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DummyCard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .DummyCardValue cardValue = 1;
  void clear_cardvalue();
  static const int kCardValueFieldNumber = 1;
  ::DummyCardValue cardvalue() const;
  void set_cardvalue(::DummyCardValue value);

  // .DummyCardSuit cardSuit = 2;
  void clear_cardsuit();
  static const int kCardSuitFieldNumber = 2;
  ::DummyCardSuit cardsuit() const;
  void set_cardsuit(::DummyCardSuit value);

  // @@protoc_insertion_point(class_scope:DummyCard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cardvalue_;
  int cardsuit_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsDummyCardImpl();
};
// -------------------------------------------------------------------

class DummyPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DummyPlayer) */ {
 public:
  DummyPlayer();
  virtual ~DummyPlayer();

  DummyPlayer(const DummyPlayer& from);

  inline DummyPlayer& operator=(const DummyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DummyPlayer(DummyPlayer&& from) noexcept
    : DummyPlayer() {
    *this = ::std::move(from);
  }

  inline DummyPlayer& operator=(DummyPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DummyPlayer* internal_default_instance() {
    return reinterpret_cast<const DummyPlayer*>(
               &_DummyPlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DummyPlayer* other);
  friend void swap(DummyPlayer& a, DummyPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DummyPlayer* New() const PROTOBUF_FINAL { return New(NULL); }

  DummyPlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DummyPlayer& from);
  void MergeFrom(const DummyPlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DummyPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DummyCard hand = 3;
  int hand_size() const;
  void clear_hand();
  static const int kHandFieldNumber = 3;
  const ::DummyCard& hand(int index) const;
  ::DummyCard* mutable_hand(int index);
  ::DummyCard* add_hand();
  ::google::protobuf::RepeatedPtrField< ::DummyCard >*
      mutable_hand();
  const ::google::protobuf::RepeatedPtrField< ::DummyCard >&
      hand() const;

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // uint32 chips = 2;
  void clear_chips();
  static const int kChipsFieldNumber = 2;
  ::google::protobuf::uint32 chips() const;
  void set_chips(::google::protobuf::uint32 value);

  // bool dealer = 4;
  void clear_dealer();
  static const int kDealerFieldNumber = 4;
  bool dealer() const;
  void set_dealer(bool value);

  // @@protoc_insertion_point(class_scope:DummyPlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DummyCard > hand_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 chips_;
  bool dealer_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsDummyPlayerImpl();
};
// -------------------------------------------------------------------

class DummyTableInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DummyTableInfo) */ {
 public:
  DummyTableInfo();
  virtual ~DummyTableInfo();

  DummyTableInfo(const DummyTableInfo& from);

  inline DummyTableInfo& operator=(const DummyTableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DummyTableInfo(DummyTableInfo&& from) noexcept
    : DummyTableInfo() {
    *this = ::std::move(from);
  }

  inline DummyTableInfo& operator=(DummyTableInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyTableInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DummyTableInfo* internal_default_instance() {
    return reinterpret_cast<const DummyTableInfo*>(
               &_DummyTableInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DummyTableInfo* other);
  friend void swap(DummyTableInfo& a, DummyTableInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DummyTableInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DummyTableInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DummyTableInfo& from);
  void MergeFrom(const DummyTableInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DummyTableInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 maxPlayers = 2;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 2;
  ::google::protobuf::uint32 maxplayers() const;
  void set_maxplayers(::google::protobuf::uint32 value);

  // uint32 players = 3;
  void clear_players();
  static const int kPlayersFieldNumber = 3;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DummyTableInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 maxplayers_;
  ::google::protobuf::uint32 players_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsDummyTableInfoImpl();
};
// -------------------------------------------------------------------

class DummyLobbyView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DummyLobbyView) */ {
 public:
  DummyLobbyView();
  virtual ~DummyLobbyView();

  DummyLobbyView(const DummyLobbyView& from);

  inline DummyLobbyView& operator=(const DummyLobbyView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DummyLobbyView(DummyLobbyView&& from) noexcept
    : DummyLobbyView() {
    *this = ::std::move(from);
  }

  inline DummyLobbyView& operator=(DummyLobbyView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyLobbyView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DummyLobbyView* internal_default_instance() {
    return reinterpret_cast<const DummyLobbyView*>(
               &_DummyLobbyView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DummyLobbyView* other);
  friend void swap(DummyLobbyView& a, DummyLobbyView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DummyLobbyView* New() const PROTOBUF_FINAL { return New(NULL); }

  DummyLobbyView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DummyLobbyView& from);
  void MergeFrom(const DummyLobbyView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DummyLobbyView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DummyTableInfo tables = 1;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 1;
  const ::DummyTableInfo& tables(int index) const;
  ::DummyTableInfo* mutable_tables(int index);
  ::DummyTableInfo* add_tables();
  ::google::protobuf::RepeatedPtrField< ::DummyTableInfo >*
      mutable_tables();
  const ::google::protobuf::RepeatedPtrField< ::DummyTableInfo >&
      tables() const;

  // @@protoc_insertion_point(class_scope:DummyLobbyView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DummyTableInfo > tables_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsDummyLobbyViewImpl();
};
// -------------------------------------------------------------------

class DummyTableView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DummyTableView) */ {
 public:
  DummyTableView();
  virtual ~DummyTableView();

  DummyTableView(const DummyTableView& from);

  inline DummyTableView& operator=(const DummyTableView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DummyTableView(DummyTableView&& from) noexcept
    : DummyTableView() {
    *this = ::std::move(from);
  }

  inline DummyTableView& operator=(DummyTableView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyTableView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DummyTableView* internal_default_instance() {
    return reinterpret_cast<const DummyTableView*>(
               &_DummyTableView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DummyTableView* other);
  friend void swap(DummyTableView& a, DummyTableView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DummyTableView* New() const PROTOBUF_FINAL { return New(NULL); }

  DummyTableView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DummyTableView& from);
  void MergeFrom(const DummyTableView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DummyTableView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DummyCard cards = 3;
  int cards_size() const;
  void clear_cards();
  static const int kCardsFieldNumber = 3;
  const ::DummyCard& cards(int index) const;
  ::DummyCard* mutable_cards(int index);
  ::DummyCard* add_cards();
  ::google::protobuf::RepeatedPtrField< ::DummyCard >*
      mutable_cards();
  const ::google::protobuf::RepeatedPtrField< ::DummyCard >&
      cards() const;

  // repeated uint32 pots = 4;
  int pots_size() const;
  void clear_pots();
  static const int kPotsFieldNumber = 4;
  ::google::protobuf::uint32 pots(int index) const;
  void set_pots(int index, ::google::protobuf::uint32 value);
  void add_pots(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pots() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pots();

  // repeated .DummyPlayer players = 5;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 5;
  const ::DummyPlayer& players(int index) const;
  ::DummyPlayer* mutable_players(int index);
  ::DummyPlayer* add_players();
  ::google::protobuf::RepeatedPtrField< ::DummyPlayer >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::DummyPlayer >&
      players() const;

  // .DummyTableStatus tableStatus = 1;
  void clear_tablestatus();
  static const int kTableStatusFieldNumber = 1;
  ::DummyTableStatus tablestatus() const;
  void set_tablestatus(::DummyTableStatus value);

  // .DummyRoundStatus roundStatus = 2;
  void clear_roundstatus();
  static const int kRoundStatusFieldNumber = 2;
  ::DummyRoundStatus roundstatus() const;
  void set_roundstatus(::DummyRoundStatus value);

  // @@protoc_insertion_point(class_scope:DummyTableView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DummyCard > cards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pots_;
  mutable int _pots_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::DummyPlayer > players_;
  int tablestatus_;
  int roundstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_Protocol_2eproto::TableStruct;
  friend void ::protobuf_Protocol_2eproto::InitDefaultsDummyTableViewImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// .Login login = 1;
inline bool Request::has_login() const {
  return payload_case() == kLogin;
}
inline void Request::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void Request::clear_login() {
  if (has_login()) {
    delete payload_.login_;
    clear_has_payload();
  }
}
inline ::Login* Request::release_login() {
  // @@protoc_insertion_point(field_release:Request.login)
  if (has_login()) {
    clear_has_payload();
      ::Login* temp = payload_.login_;
    payload_.login_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Login& Request::login() const {
  // @@protoc_insertion_point(field_get:Request.login)
  return has_login()
      ? *payload_.login_
      : *reinterpret_cast< ::Login*>(&::_Login_default_instance_);
}
inline ::Login* Request::mutable_login() {
  if (!has_login()) {
    clear_payload();
    set_has_login();
    payload_.login_ = new ::Login;
  }
  // @@protoc_insertion_point(field_mutable:Request.login)
  return payload_.login_;
}

// .CreateTable createTable = 2;
inline bool Request::has_createtable() const {
  return payload_case() == kCreateTable;
}
inline void Request::set_has_createtable() {
  _oneof_case_[0] = kCreateTable;
}
inline void Request::clear_createtable() {
  if (has_createtable()) {
    delete payload_.createtable_;
    clear_has_payload();
  }
}
inline ::CreateTable* Request::release_createtable() {
  // @@protoc_insertion_point(field_release:Request.createTable)
  if (has_createtable()) {
    clear_has_payload();
      ::CreateTable* temp = payload_.createtable_;
    payload_.createtable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::CreateTable& Request::createtable() const {
  // @@protoc_insertion_point(field_get:Request.createTable)
  return has_createtable()
      ? *payload_.createtable_
      : *reinterpret_cast< ::CreateTable*>(&::_CreateTable_default_instance_);
}
inline ::CreateTable* Request::mutable_createtable() {
  if (!has_createtable()) {
    clear_payload();
    set_has_createtable();
    payload_.createtable_ = new ::CreateTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.createTable)
  return payload_.createtable_;
}

// .JoinTable joinTable = 3;
inline bool Request::has_jointable() const {
  return payload_case() == kJoinTable;
}
inline void Request::set_has_jointable() {
  _oneof_case_[0] = kJoinTable;
}
inline void Request::clear_jointable() {
  if (has_jointable()) {
    delete payload_.jointable_;
    clear_has_payload();
  }
}
inline ::JoinTable* Request::release_jointable() {
  // @@protoc_insertion_point(field_release:Request.joinTable)
  if (has_jointable()) {
    clear_has_payload();
      ::JoinTable* temp = payload_.jointable_;
    payload_.jointable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::JoinTable& Request::jointable() const {
  // @@protoc_insertion_point(field_get:Request.joinTable)
  return has_jointable()
      ? *payload_.jointable_
      : *reinterpret_cast< ::JoinTable*>(&::_JoinTable_default_instance_);
}
inline ::JoinTable* Request::mutable_jointable() {
  if (!has_jointable()) {
    clear_payload();
    set_has_jointable();
    payload_.jointable_ = new ::JoinTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.joinTable)
  return payload_.jointable_;
}

// .LeaveTable leaveTable = 4;
inline bool Request::has_leavetable() const {
  return payload_case() == kLeaveTable;
}
inline void Request::set_has_leavetable() {
  _oneof_case_[0] = kLeaveTable;
}
inline void Request::clear_leavetable() {
  if (has_leavetable()) {
    delete payload_.leavetable_;
    clear_has_payload();
  }
}
inline ::LeaveTable* Request::release_leavetable() {
  // @@protoc_insertion_point(field_release:Request.leaveTable)
  if (has_leavetable()) {
    clear_has_payload();
      ::LeaveTable* temp = payload_.leavetable_;
    payload_.leavetable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LeaveTable& Request::leavetable() const {
  // @@protoc_insertion_point(field_get:Request.leaveTable)
  return has_leavetable()
      ? *payload_.leavetable_
      : *reinterpret_cast< ::LeaveTable*>(&::_LeaveTable_default_instance_);
}
inline ::LeaveTable* Request::mutable_leavetable() {
  if (!has_leavetable()) {
    clear_payload();
    set_has_leavetable();
    payload_.leavetable_ = new ::LeaveTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.leaveTable)
  return payload_.leavetable_;
}

// .Raise raise = 5;
inline bool Request::has_raise() const {
  return payload_case() == kRaise;
}
inline void Request::set_has_raise() {
  _oneof_case_[0] = kRaise;
}
inline void Request::clear_raise() {
  if (has_raise()) {
    delete payload_.raise_;
    clear_has_payload();
  }
}
inline ::Raise* Request::release_raise() {
  // @@protoc_insertion_point(field_release:Request.raise)
  if (has_raise()) {
    clear_has_payload();
      ::Raise* temp = payload_.raise_;
    payload_.raise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Raise& Request::raise() const {
  // @@protoc_insertion_point(field_get:Request.raise)
  return has_raise()
      ? *payload_.raise_
      : *reinterpret_cast< ::Raise*>(&::_Raise_default_instance_);
}
inline ::Raise* Request::mutable_raise() {
  if (!has_raise()) {
    clear_payload();
    set_has_raise();
    payload_.raise_ = new ::Raise;
  }
  // @@protoc_insertion_point(field_mutable:Request.raise)
  return payload_.raise_;
}

// .Fold fold = 6;
inline bool Request::has_fold() const {
  return payload_case() == kFold;
}
inline void Request::set_has_fold() {
  _oneof_case_[0] = kFold;
}
inline void Request::clear_fold() {
  if (has_fold()) {
    delete payload_.fold_;
    clear_has_payload();
  }
}
inline ::Fold* Request::release_fold() {
  // @@protoc_insertion_point(field_release:Request.fold)
  if (has_fold()) {
    clear_has_payload();
      ::Fold* temp = payload_.fold_;
    payload_.fold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Fold& Request::fold() const {
  // @@protoc_insertion_point(field_get:Request.fold)
  return has_fold()
      ? *payload_.fold_
      : *reinterpret_cast< ::Fold*>(&::_Fold_default_instance_);
}
inline ::Fold* Request::mutable_fold() {
  if (!has_fold()) {
    clear_payload();
    set_has_fold();
    payload_.fold_ = new ::Fold;
  }
  // @@protoc_insertion_point(field_mutable:Request.fold)
  return payload_.fold_;
}

// .Call call = 7;
inline bool Request::has_call() const {
  return payload_case() == kCall;
}
inline void Request::set_has_call() {
  _oneof_case_[0] = kCall;
}
inline void Request::clear_call() {
  if (has_call()) {
    delete payload_.call_;
    clear_has_payload();
  }
}
inline ::Call* Request::release_call() {
  // @@protoc_insertion_point(field_release:Request.call)
  if (has_call()) {
    clear_has_payload();
      ::Call* temp = payload_.call_;
    payload_.call_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Call& Request::call() const {
  // @@protoc_insertion_point(field_get:Request.call)
  return has_call()
      ? *payload_.call_
      : *reinterpret_cast< ::Call*>(&::_Call_default_instance_);
}
inline ::Call* Request::mutable_call() {
  if (!has_call()) {
    clear_payload();
    set_has_call();
    payload_.call_ = new ::Call;
  }
  // @@protoc_insertion_point(field_mutable:Request.call)
  return payload_.call_;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .Error error = 1;
inline void Response::clear_error() {
  error_ = 0;
}
inline ::Error Response::error() const {
  // @@protoc_insertion_point(field_get:Response.error)
  return static_cast< ::Error >(error_);
}
inline void Response::set_error(::Error value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:Response.error)
}

// .DummyLobbyView lobbyView = 2;
inline bool Response::has_lobbyview() const {
  return payload_case() == kLobbyView;
}
inline void Response::set_has_lobbyview() {
  _oneof_case_[0] = kLobbyView;
}
inline void Response::clear_lobbyview() {
  if (has_lobbyview()) {
    delete payload_.lobbyview_;
    clear_has_payload();
  }
}
inline ::DummyLobbyView* Response::release_lobbyview() {
  // @@protoc_insertion_point(field_release:Response.lobbyView)
  if (has_lobbyview()) {
    clear_has_payload();
      ::DummyLobbyView* temp = payload_.lobbyview_;
    payload_.lobbyview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::DummyLobbyView& Response::lobbyview() const {
  // @@protoc_insertion_point(field_get:Response.lobbyView)
  return has_lobbyview()
      ? *payload_.lobbyview_
      : *reinterpret_cast< ::DummyLobbyView*>(&::_DummyLobbyView_default_instance_);
}
inline ::DummyLobbyView* Response::mutable_lobbyview() {
  if (!has_lobbyview()) {
    clear_payload();
    set_has_lobbyview();
    payload_.lobbyview_ = new ::DummyLobbyView;
  }
  // @@protoc_insertion_point(field_mutable:Response.lobbyView)
  return payload_.lobbyview_;
}

// .DummyTableView tableView = 3;
inline bool Response::has_tableview() const {
  return payload_case() == kTableView;
}
inline void Response::set_has_tableview() {
  _oneof_case_[0] = kTableView;
}
inline void Response::clear_tableview() {
  if (has_tableview()) {
    delete payload_.tableview_;
    clear_has_payload();
  }
}
inline ::DummyTableView* Response::release_tableview() {
  // @@protoc_insertion_point(field_release:Response.tableView)
  if (has_tableview()) {
    clear_has_payload();
      ::DummyTableView* temp = payload_.tableview_;
    payload_.tableview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::DummyTableView& Response::tableview() const {
  // @@protoc_insertion_point(field_get:Response.tableView)
  return has_tableview()
      ? *payload_.tableview_
      : *reinterpret_cast< ::DummyTableView*>(&::_DummyTableView_default_instance_);
}
inline ::DummyTableView* Response::mutable_tableview() {
  if (!has_tableview()) {
    clear_payload();
    set_has_tableview();
    payload_.tableview_ = new ::DummyTableView;
  }
  // @@protoc_insertion_point(field_mutable:Response.tableView)
  return payload_.tableview_;
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Login

// string username = 1;
inline void Login::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:Login.username)
  return username_.GetNoArena();
}
inline void Login::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.username)
}
#if LANG_CXX11
inline void Login::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.username)
}
#endif
inline void Login::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.username)
}
inline void Login::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.username)
}
inline ::std::string* Login::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Login.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:Login.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Login.username)
}

// -------------------------------------------------------------------

// CreateTable

// string name = 1;
inline void CreateTable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTable::name() const {
  // @@protoc_insertion_point(field_get:CreateTable.name)
  return name_.GetNoArena();
}
inline void CreateTable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CreateTable.name)
}
#if LANG_CXX11
inline void CreateTable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CreateTable.name)
}
#endif
inline void CreateTable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CreateTable.name)
}
inline void CreateTable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CreateTable.name)
}
inline ::std::string* CreateTable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:CreateTable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTable::release_name() {
  // @@protoc_insertion_point(field_release:CreateTable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:CreateTable.name)
}

// uint32 maxPlayers = 2;
inline void CreateTable::clear_maxplayers() {
  maxplayers_ = 0u;
}
inline ::google::protobuf::uint32 CreateTable::maxplayers() const {
  // @@protoc_insertion_point(field_get:CreateTable.maxPlayers)
  return maxplayers_;
}
inline void CreateTable::set_maxplayers(::google::protobuf::uint32 value) {
  
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:CreateTable.maxPlayers)
}

// -------------------------------------------------------------------

// JoinTable

// string name = 1;
inline void JoinTable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinTable::name() const {
  // @@protoc_insertion_point(field_get:JoinTable.name)
  return name_.GetNoArena();
}
inline void JoinTable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinTable.name)
}
#if LANG_CXX11
inline void JoinTable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinTable.name)
}
#endif
inline void JoinTable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinTable.name)
}
inline void JoinTable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinTable.name)
}
inline ::std::string* JoinTable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:JoinTable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinTable::release_name() {
  // @@protoc_insertion_point(field_release:JoinTable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinTable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:JoinTable.name)
}

// -------------------------------------------------------------------

// LeaveTable

// string name = 1;
inline void LeaveTable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LeaveTable::name() const {
  // @@protoc_insertion_point(field_get:LeaveTable.name)
  return name_.GetNoArena();
}
inline void LeaveTable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LeaveTable.name)
}
#if LANG_CXX11
inline void LeaveTable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LeaveTable.name)
}
#endif
inline void LeaveTable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LeaveTable.name)
}
inline void LeaveTable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LeaveTable.name)
}
inline ::std::string* LeaveTable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:LeaveTable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaveTable::release_name() {
  // @@protoc_insertion_point(field_release:LeaveTable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaveTable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:LeaveTable.name)
}

// -------------------------------------------------------------------

// Raise

// int32 chips = 1;
inline void Raise::clear_chips() {
  chips_ = 0;
}
inline ::google::protobuf::int32 Raise::chips() const {
  // @@protoc_insertion_point(field_get:Raise.chips)
  return chips_;
}
inline void Raise::set_chips(::google::protobuf::int32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:Raise.chips)
}

// -------------------------------------------------------------------

// Fold

// -------------------------------------------------------------------

// Call

// -------------------------------------------------------------------

// DummyCard

// .DummyCardValue cardValue = 1;
inline void DummyCard::clear_cardvalue() {
  cardvalue_ = 0;
}
inline ::DummyCardValue DummyCard::cardvalue() const {
  // @@protoc_insertion_point(field_get:DummyCard.cardValue)
  return static_cast< ::DummyCardValue >(cardvalue_);
}
inline void DummyCard::set_cardvalue(::DummyCardValue value) {
  
  cardvalue_ = value;
  // @@protoc_insertion_point(field_set:DummyCard.cardValue)
}

// .DummyCardSuit cardSuit = 2;
inline void DummyCard::clear_cardsuit() {
  cardsuit_ = 0;
}
inline ::DummyCardSuit DummyCard::cardsuit() const {
  // @@protoc_insertion_point(field_get:DummyCard.cardSuit)
  return static_cast< ::DummyCardSuit >(cardsuit_);
}
inline void DummyCard::set_cardsuit(::DummyCardSuit value) {
  
  cardsuit_ = value;
  // @@protoc_insertion_point(field_set:DummyCard.cardSuit)
}

// -------------------------------------------------------------------

// DummyPlayer

// string username = 1;
inline void DummyPlayer::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DummyPlayer::username() const {
  // @@protoc_insertion_point(field_get:DummyPlayer.username)
  return username_.GetNoArena();
}
inline void DummyPlayer::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DummyPlayer.username)
}
#if LANG_CXX11
inline void DummyPlayer::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DummyPlayer.username)
}
#endif
inline void DummyPlayer::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DummyPlayer.username)
}
inline void DummyPlayer::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DummyPlayer.username)
}
inline ::std::string* DummyPlayer::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:DummyPlayer.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DummyPlayer::release_username() {
  // @@protoc_insertion_point(field_release:DummyPlayer.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DummyPlayer::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:DummyPlayer.username)
}

// uint32 chips = 2;
inline void DummyPlayer::clear_chips() {
  chips_ = 0u;
}
inline ::google::protobuf::uint32 DummyPlayer::chips() const {
  // @@protoc_insertion_point(field_get:DummyPlayer.chips)
  return chips_;
}
inline void DummyPlayer::set_chips(::google::protobuf::uint32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:DummyPlayer.chips)
}

// repeated .DummyCard hand = 3;
inline int DummyPlayer::hand_size() const {
  return hand_.size();
}
inline void DummyPlayer::clear_hand() {
  hand_.Clear();
}
inline const ::DummyCard& DummyPlayer::hand(int index) const {
  // @@protoc_insertion_point(field_get:DummyPlayer.hand)
  return hand_.Get(index);
}
inline ::DummyCard* DummyPlayer::mutable_hand(int index) {
  // @@protoc_insertion_point(field_mutable:DummyPlayer.hand)
  return hand_.Mutable(index);
}
inline ::DummyCard* DummyPlayer::add_hand() {
  // @@protoc_insertion_point(field_add:DummyPlayer.hand)
  return hand_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DummyCard >*
DummyPlayer::mutable_hand() {
  // @@protoc_insertion_point(field_mutable_list:DummyPlayer.hand)
  return &hand_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DummyCard >&
DummyPlayer::hand() const {
  // @@protoc_insertion_point(field_list:DummyPlayer.hand)
  return hand_;
}

// bool dealer = 4;
inline void DummyPlayer::clear_dealer() {
  dealer_ = false;
}
inline bool DummyPlayer::dealer() const {
  // @@protoc_insertion_point(field_get:DummyPlayer.dealer)
  return dealer_;
}
inline void DummyPlayer::set_dealer(bool value) {
  
  dealer_ = value;
  // @@protoc_insertion_point(field_set:DummyPlayer.dealer)
}

// -------------------------------------------------------------------

// DummyTableInfo

// string name = 1;
inline void DummyTableInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DummyTableInfo::name() const {
  // @@protoc_insertion_point(field_get:DummyTableInfo.name)
  return name_.GetNoArena();
}
inline void DummyTableInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DummyTableInfo.name)
}
#if LANG_CXX11
inline void DummyTableInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DummyTableInfo.name)
}
#endif
inline void DummyTableInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DummyTableInfo.name)
}
inline void DummyTableInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DummyTableInfo.name)
}
inline ::std::string* DummyTableInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:DummyTableInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DummyTableInfo::release_name() {
  // @@protoc_insertion_point(field_release:DummyTableInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DummyTableInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:DummyTableInfo.name)
}

// uint32 maxPlayers = 2;
inline void DummyTableInfo::clear_maxplayers() {
  maxplayers_ = 0u;
}
inline ::google::protobuf::uint32 DummyTableInfo::maxplayers() const {
  // @@protoc_insertion_point(field_get:DummyTableInfo.maxPlayers)
  return maxplayers_;
}
inline void DummyTableInfo::set_maxplayers(::google::protobuf::uint32 value) {
  
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:DummyTableInfo.maxPlayers)
}

// uint32 players = 3;
inline void DummyTableInfo::clear_players() {
  players_ = 0u;
}
inline ::google::protobuf::uint32 DummyTableInfo::players() const {
  // @@protoc_insertion_point(field_get:DummyTableInfo.players)
  return players_;
}
inline void DummyTableInfo::set_players(::google::protobuf::uint32 value) {
  
  players_ = value;
  // @@protoc_insertion_point(field_set:DummyTableInfo.players)
}

// -------------------------------------------------------------------

// DummyLobbyView

// repeated .DummyTableInfo tables = 1;
inline int DummyLobbyView::tables_size() const {
  return tables_.size();
}
inline void DummyLobbyView::clear_tables() {
  tables_.Clear();
}
inline const ::DummyTableInfo& DummyLobbyView::tables(int index) const {
  // @@protoc_insertion_point(field_get:DummyLobbyView.tables)
  return tables_.Get(index);
}
inline ::DummyTableInfo* DummyLobbyView::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:DummyLobbyView.tables)
  return tables_.Mutable(index);
}
inline ::DummyTableInfo* DummyLobbyView::add_tables() {
  // @@protoc_insertion_point(field_add:DummyLobbyView.tables)
  return tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DummyTableInfo >*
DummyLobbyView::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:DummyLobbyView.tables)
  return &tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DummyTableInfo >&
DummyLobbyView::tables() const {
  // @@protoc_insertion_point(field_list:DummyLobbyView.tables)
  return tables_;
}

// -------------------------------------------------------------------

// DummyTableView

// .DummyTableStatus tableStatus = 1;
inline void DummyTableView::clear_tablestatus() {
  tablestatus_ = 0;
}
inline ::DummyTableStatus DummyTableView::tablestatus() const {
  // @@protoc_insertion_point(field_get:DummyTableView.tableStatus)
  return static_cast< ::DummyTableStatus >(tablestatus_);
}
inline void DummyTableView::set_tablestatus(::DummyTableStatus value) {
  
  tablestatus_ = value;
  // @@protoc_insertion_point(field_set:DummyTableView.tableStatus)
}

// .DummyRoundStatus roundStatus = 2;
inline void DummyTableView::clear_roundstatus() {
  roundstatus_ = 0;
}
inline ::DummyRoundStatus DummyTableView::roundstatus() const {
  // @@protoc_insertion_point(field_get:DummyTableView.roundStatus)
  return static_cast< ::DummyRoundStatus >(roundstatus_);
}
inline void DummyTableView::set_roundstatus(::DummyRoundStatus value) {
  
  roundstatus_ = value;
  // @@protoc_insertion_point(field_set:DummyTableView.roundStatus)
}

// repeated .DummyCard cards = 3;
inline int DummyTableView::cards_size() const {
  return cards_.size();
}
inline void DummyTableView::clear_cards() {
  cards_.Clear();
}
inline const ::DummyCard& DummyTableView::cards(int index) const {
  // @@protoc_insertion_point(field_get:DummyTableView.cards)
  return cards_.Get(index);
}
inline ::DummyCard* DummyTableView::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:DummyTableView.cards)
  return cards_.Mutable(index);
}
inline ::DummyCard* DummyTableView::add_cards() {
  // @@protoc_insertion_point(field_add:DummyTableView.cards)
  return cards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DummyCard >*
DummyTableView::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:DummyTableView.cards)
  return &cards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DummyCard >&
DummyTableView::cards() const {
  // @@protoc_insertion_point(field_list:DummyTableView.cards)
  return cards_;
}

// repeated uint32 pots = 4;
inline int DummyTableView::pots_size() const {
  return pots_.size();
}
inline void DummyTableView::clear_pots() {
  pots_.Clear();
}
inline ::google::protobuf::uint32 DummyTableView::pots(int index) const {
  // @@protoc_insertion_point(field_get:DummyTableView.pots)
  return pots_.Get(index);
}
inline void DummyTableView::set_pots(int index, ::google::protobuf::uint32 value) {
  pots_.Set(index, value);
  // @@protoc_insertion_point(field_set:DummyTableView.pots)
}
inline void DummyTableView::add_pots(::google::protobuf::uint32 value) {
  pots_.Add(value);
  // @@protoc_insertion_point(field_add:DummyTableView.pots)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DummyTableView::pots() const {
  // @@protoc_insertion_point(field_list:DummyTableView.pots)
  return pots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DummyTableView::mutable_pots() {
  // @@protoc_insertion_point(field_mutable_list:DummyTableView.pots)
  return &pots_;
}

// repeated .DummyPlayer players = 5;
inline int DummyTableView::players_size() const {
  return players_.size();
}
inline void DummyTableView::clear_players() {
  players_.Clear();
}
inline const ::DummyPlayer& DummyTableView::players(int index) const {
  // @@protoc_insertion_point(field_get:DummyTableView.players)
  return players_.Get(index);
}
inline ::DummyPlayer* DummyTableView::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:DummyTableView.players)
  return players_.Mutable(index);
}
inline ::DummyPlayer* DummyTableView::add_players() {
  // @@protoc_insertion_point(field_add:DummyTableView.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DummyPlayer >*
DummyTableView::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:DummyTableView.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DummyPlayer >&
DummyTableView::players() const {
  // @@protoc_insertion_point(field_list:DummyTableView.players)
  return players_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Error>() {
  return ::Error_descriptor();
}
template <> struct is_proto_enum< ::DummyTableStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DummyTableStatus>() {
  return ::DummyTableStatus_descriptor();
}
template <> struct is_proto_enum< ::DummyRoundStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DummyRoundStatus>() {
  return ::DummyRoundStatus_descriptor();
}
template <> struct is_proto_enum< ::DummyCardValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DummyCardValue>() {
  return ::DummyCardValue_descriptor();
}
template <> struct is_proto_enum< ::DummyCardSuit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DummyCardSuit>() {
  return ::DummyCardSuit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Protocol_2eproto__INCLUDED
