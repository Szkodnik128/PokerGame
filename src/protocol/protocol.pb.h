// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestImpl();
void InitDefaultsRequest();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
void InitDefaultsJoinTableImpl();
void InitDefaultsJoinTable();
void InitDefaultsLeaveTableImpl();
void InitDefaultsLeaveTable();
void InitDefaultsRaiseImpl();
void InitDefaultsRaise();
void InitDefaultsFoldImpl();
void InitDefaultsFold();
void InitDefaultsCallImpl();
void InitDefaultsCall();
void InitDefaultsCardImpl();
void InitDefaultsCard();
void InitDefaultsPlayerImpl();
void InitDefaultsPlayer();
void InitDefaultsTableInfoImpl();
void InitDefaultsTableInfo();
void InitDefaultsLobbyViewImpl();
void InitDefaultsLobbyView();
void InitDefaultsTableViewImpl();
void InitDefaultsTableView();
inline void InitDefaults() {
  InitDefaultsRequest();
  InitDefaultsResponse();
  InitDefaultsLogin();
  InitDefaultsJoinTable();
  InitDefaultsLeaveTable();
  InitDefaultsRaise();
  InitDefaultsFold();
  InitDefaultsCall();
  InitDefaultsCard();
  InitDefaultsPlayer();
  InitDefaultsTableInfo();
  InitDefaultsLobbyView();
  InitDefaultsTableView();
}
}  // namespace protobuf_protocol_2eproto
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class Card;
class CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class Fold;
class FoldDefaultTypeInternal;
extern FoldDefaultTypeInternal _Fold_default_instance_;
class JoinTable;
class JoinTableDefaultTypeInternal;
extern JoinTableDefaultTypeInternal _JoinTable_default_instance_;
class LeaveTable;
class LeaveTableDefaultTypeInternal;
extern LeaveTableDefaultTypeInternal _LeaveTable_default_instance_;
class LobbyView;
class LobbyViewDefaultTypeInternal;
extern LobbyViewDefaultTypeInternal _LobbyView_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Raise;
class RaiseDefaultTypeInternal;
extern RaiseDefaultTypeInternal _Raise_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class TableInfo;
class TableInfoDefaultTypeInternal;
extern TableInfoDefaultTypeInternal _TableInfo_default_instance_;
class TableView;
class TableViewDefaultTypeInternal;
extern TableViewDefaultTypeInternal _TableView_default_instance_;

enum Error {
  ErrorSuccess = 0,
  ErrorWrongMessage = 1,
  ErrorInvalidValue = 2,
  Error_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Error_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Error_IsValid(int value);
const Error Error_MIN = ErrorSuccess;
const Error Error_MAX = ErrorInvalidValue;
const int Error_ARRAYSIZE = Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_descriptor();
inline const ::std::string& Error_Name(Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_descriptor(), value);
}
inline bool Error_Parse(
    const ::std::string& name, Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error>(
    Error_descriptor(), name, value);
}
enum TableStatus {
  TableStatusUnknown = 0,
  TableStatusWaitingForPlayers = 1,
  TableStatusGameInProgress = 2,
  TableStatusGameEnded = 3,
  TableStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TableStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TableStatus_IsValid(int value);
const TableStatus TableStatus_MIN = TableStatusUnknown;
const TableStatus TableStatus_MAX = TableStatusGameEnded;
const int TableStatus_ARRAYSIZE = TableStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableStatus_descriptor();
inline const ::std::string& TableStatus_Name(TableStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableStatus_descriptor(), value);
}
inline bool TableStatus_Parse(
    const ::std::string& name, TableStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableStatus>(
    TableStatus_descriptor(), name, value);
}
enum RoundStatus {
  RoundStatusUnknown = 0,
  RoundStatusPreFlop = 1,
  RoundStatusFlop = 2,
  RoundStatusTurn = 3,
  RoundStatusRiver = 4,
  RoundStatusEnd = 5,
  RoundStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoundStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoundStatus_IsValid(int value);
const RoundStatus RoundStatus_MIN = RoundStatusUnknown;
const RoundStatus RoundStatus_MAX = RoundStatusEnd;
const int RoundStatus_ARRAYSIZE = RoundStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoundStatus_descriptor();
inline const ::std::string& RoundStatus_Name(RoundStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoundStatus_descriptor(), value);
}
inline bool RoundStatus_Parse(
    const ::std::string& name, RoundStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoundStatus>(
    RoundStatus_descriptor(), name, value);
}
enum CardValue {
  CardValueUnkown = 0,
  CardValueTwo = 2,
  CardValueThree = 3,
  CardValueFour = 4,
  CardValueFive = 5,
  CardValueSix = 6,
  CardValueSeven = 7,
  CardValueEight = 8,
  CardValueNine = 9,
  CardValueTen = 10,
  CardValueJack = 11,
  CardValueQueen = 12,
  CardValueKing = 13,
  CardValueAce = 14,
  CardValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CardValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CardValue_IsValid(int value);
const CardValue CardValue_MIN = CardValueUnkown;
const CardValue CardValue_MAX = CardValueAce;
const int CardValue_ARRAYSIZE = CardValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* CardValue_descriptor();
inline const ::std::string& CardValue_Name(CardValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    CardValue_descriptor(), value);
}
inline bool CardValue_Parse(
    const ::std::string& name, CardValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CardValue>(
    CardValue_descriptor(), name, value);
}
enum CardSuit {
  CardSuitUnkown = 0,
  CardSuitSpades = 1,
  CardSuitHearts = 2,
  CardSuitDiamonds = 3,
  CardSuitClubs = 4,
  CardSuit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CardSuit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CardSuit_IsValid(int value);
const CardSuit CardSuit_MIN = CardSuitUnkown;
const CardSuit CardSuit_MAX = CardSuitClubs;
const int CardSuit_ARRAYSIZE = CardSuit_MAX + 1;

const ::google::protobuf::EnumDescriptor* CardSuit_descriptor();
inline const ::std::string& CardSuit_Name(CardSuit value) {
  return ::google::protobuf::internal::NameOfEnum(
    CardSuit_descriptor(), value);
}
inline bool CardSuit_Parse(
    const ::std::string& name, CardSuit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CardSuit>(
    CardSuit_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum PayloadCase {
    kLogin = 1,
    kJoinTable = 2,
    kLeaveTable = 3,
    kRaise = 4,
    kFold = 5,
    kCall = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Login login = 1;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::Login& login() const;
  ::Login* release_login();
  ::Login* mutable_login();
  void set_allocated_login(::Login* login);

  // .JoinTable joinTable = 2;
  bool has_jointable() const;
  void clear_jointable();
  static const int kJoinTableFieldNumber = 2;
  const ::JoinTable& jointable() const;
  ::JoinTable* release_jointable();
  ::JoinTable* mutable_jointable();
  void set_allocated_jointable(::JoinTable* jointable);

  // .LeaveTable leaveTable = 3;
  bool has_leavetable() const;
  void clear_leavetable();
  static const int kLeaveTableFieldNumber = 3;
  const ::LeaveTable& leavetable() const;
  ::LeaveTable* release_leavetable();
  ::LeaveTable* mutable_leavetable();
  void set_allocated_leavetable(::LeaveTable* leavetable);

  // .Raise raise = 4;
  bool has_raise() const;
  void clear_raise();
  static const int kRaiseFieldNumber = 4;
  const ::Raise& raise() const;
  ::Raise* release_raise();
  ::Raise* mutable_raise();
  void set_allocated_raise(::Raise* raise);

  // .Fold fold = 5;
  bool has_fold() const;
  void clear_fold();
  static const int kFoldFieldNumber = 5;
  const ::Fold& fold() const;
  ::Fold* release_fold();
  ::Fold* mutable_fold();
  void set_allocated_fold(::Fold* fold);

  // .Call call = 6;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 6;
  const ::Call& call() const;
  ::Call* release_call();
  ::Call* mutable_call();
  void set_allocated_call(::Call* call);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Request)
 private:
  void set_has_login();
  void set_has_jointable();
  void set_has_leavetable();
  void set_has_raise();
  void set_has_fold();
  void set_has_call();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::Login* login_;
    ::JoinTable* jointable_;
    ::LeaveTable* leavetable_;
    ::Raise* raise_;
    ::Fold* fold_;
    ::Call* call_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsRequestImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum PayloadCase {
    kLobbyView = 2,
    kTableView = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Error error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Error error() const;
  void set_error(::Error value);

  // .LobbyView lobbyView = 2;
  bool has_lobbyview() const;
  void clear_lobbyview();
  static const int kLobbyViewFieldNumber = 2;
  const ::LobbyView& lobbyview() const;
  ::LobbyView* release_lobbyview();
  ::LobbyView* mutable_lobbyview();
  void set_allocated_lobbyview(::LobbyView* lobbyview);

  // .TableView tableView = 3;
  bool has_tableview() const;
  void clear_tableview();
  static const int kTableViewFieldNumber = 3;
  const ::TableView& tableview() const;
  ::TableView* release_tableview();
  ::TableView* mutable_tableview();
  void set_allocated_tableview(::TableView* tableview);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Response)
 private:
  void set_has_lobbyview();
  void set_has_tableview();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_;
  union PayloadUnion {
    PayloadUnion() {}
    ::LobbyView* lobbyview_;
    ::TableView* tableview_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsLoginImpl();
};
// -------------------------------------------------------------------

class JoinTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinTable) */ {
 public:
  JoinTable();
  virtual ~JoinTable();

  JoinTable(const JoinTable& from);

  inline JoinTable& operator=(const JoinTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinTable(JoinTable&& from) noexcept
    : JoinTable() {
    *this = ::std::move(from);
  }

  inline JoinTable& operator=(JoinTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinTable* internal_default_instance() {
    return reinterpret_cast<const JoinTable*>(
               &_JoinTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(JoinTable* other);
  friend void swap(JoinTable& a, JoinTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinTable* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinTable& from);
  void MergeFrom(const JoinTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 tableId = 1;
  void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  ::google::protobuf::uint32 tableid() const;
  void set_tableid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 tableid_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsJoinTableImpl();
};
// -------------------------------------------------------------------

class LeaveTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeaveTable) */ {
 public:
  LeaveTable();
  virtual ~LeaveTable();

  LeaveTable(const LeaveTable& from);

  inline LeaveTable& operator=(const LeaveTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveTable(LeaveTable&& from) noexcept
    : LeaveTable() {
    *this = ::std::move(from);
  }

  inline LeaveTable& operator=(LeaveTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveTable* internal_default_instance() {
    return reinterpret_cast<const LeaveTable*>(
               &_LeaveTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LeaveTable* other);
  friend void swap(LeaveTable& a, LeaveTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveTable* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveTable& from);
  void MergeFrom(const LeaveTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:LeaveTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsLeaveTableImpl();
};
// -------------------------------------------------------------------

class Raise : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Raise) */ {
 public:
  Raise();
  virtual ~Raise();

  Raise(const Raise& from);

  inline Raise& operator=(const Raise& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Raise(Raise&& from) noexcept
    : Raise() {
    *this = ::std::move(from);
  }

  inline Raise& operator=(Raise&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Raise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Raise* internal_default_instance() {
    return reinterpret_cast<const Raise*>(
               &_Raise_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Raise* other);
  friend void swap(Raise& a, Raise& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Raise* New() const PROTOBUF_FINAL { return New(NULL); }

  Raise* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Raise& from);
  void MergeFrom(const Raise& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Raise* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 chips = 1;
  void clear_chips();
  static const int kChipsFieldNumber = 1;
  ::google::protobuf::int32 chips() const;
  void set_chips(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Raise)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 chips_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsRaiseImpl();
};
// -------------------------------------------------------------------

class Fold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Fold) */ {
 public:
  Fold();
  virtual ~Fold();

  Fold(const Fold& from);

  inline Fold& operator=(const Fold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fold(Fold&& from) noexcept
    : Fold() {
    *this = ::std::move(from);
  }

  inline Fold& operator=(Fold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fold* internal_default_instance() {
    return reinterpret_cast<const Fold*>(
               &_Fold_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Fold* other);
  friend void swap(Fold& a, Fold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fold* New() const PROTOBUF_FINAL { return New(NULL); }

  Fold* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fold& from);
  void MergeFrom(const Fold& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Fold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsFoldImpl();
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Call)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCallImpl();
};
// -------------------------------------------------------------------

class Card : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Card) */ {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(Card&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Card& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Card* other);
  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const PROTOBUF_FINAL { return New(NULL); }

  Card* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Card* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CardValue cardValue = 1;
  void clear_cardvalue();
  static const int kCardValueFieldNumber = 1;
  ::CardValue cardvalue() const;
  void set_cardvalue(::CardValue value);

  // .CardSuit cardSuit = 2;
  void clear_cardsuit();
  static const int kCardSuitFieldNumber = 2;
  ::CardSuit cardsuit() const;
  void set_cardsuit(::CardSuit value);

  // @@protoc_insertion_point(class_scope:Card)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cardvalue_;
  int cardsuit_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsCardImpl();
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const PROTOBUF_FINAL { return New(NULL); }

  Player* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Card hand = 3;
  int hand_size() const;
  void clear_hand();
  static const int kHandFieldNumber = 3;
  const ::Card& hand(int index) const;
  ::Card* mutable_hand(int index);
  ::Card* add_hand();
  ::google::protobuf::RepeatedPtrField< ::Card >*
      mutable_hand();
  const ::google::protobuf::RepeatedPtrField< ::Card >&
      hand() const;

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // uint32 chips = 2;
  void clear_chips();
  static const int kChipsFieldNumber = 2;
  ::google::protobuf::uint32 chips() const;
  void set_chips(::google::protobuf::uint32 value);

  // bool dealer = 4;
  void clear_dealer();
  static const int kDealerFieldNumber = 4;
  bool dealer() const;
  void set_dealer(bool value);

  // @@protoc_insertion_point(class_scope:Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Card > hand_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 chips_;
  bool dealer_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsPlayerImpl();
};
// -------------------------------------------------------------------

class TableInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TableInfo) */ {
 public:
  TableInfo();
  virtual ~TableInfo();

  TableInfo(const TableInfo& from);

  inline TableInfo& operator=(const TableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableInfo(TableInfo&& from) noexcept
    : TableInfo() {
    *this = ::std::move(from);
  }

  inline TableInfo& operator=(TableInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableInfo* internal_default_instance() {
    return reinterpret_cast<const TableInfo*>(
               &_TableInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(TableInfo* other);
  friend void swap(TableInfo& a, TableInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TableInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TableInfo& from);
  void MergeFrom(const TableInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TableInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // uint32 maxPlayers = 3;
  void clear_maxplayers();
  static const int kMaxPlayersFieldNumber = 3;
  ::google::protobuf::uint32 maxplayers() const;
  void set_maxplayers(::google::protobuf::uint32 value);

  // uint32 players = 4;
  void clear_players();
  static const int kPlayersFieldNumber = 4;
  ::google::protobuf::uint32 players() const;
  void set_players(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TableInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 maxplayers_;
  ::google::protobuf::uint32 players_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsTableInfoImpl();
};
// -------------------------------------------------------------------

class LobbyView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LobbyView) */ {
 public:
  LobbyView();
  virtual ~LobbyView();

  LobbyView(const LobbyView& from);

  inline LobbyView& operator=(const LobbyView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LobbyView(LobbyView&& from) noexcept
    : LobbyView() {
    *this = ::std::move(from);
  }

  inline LobbyView& operator=(LobbyView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LobbyView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LobbyView* internal_default_instance() {
    return reinterpret_cast<const LobbyView*>(
               &_LobbyView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(LobbyView* other);
  friend void swap(LobbyView& a, LobbyView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LobbyView* New() const PROTOBUF_FINAL { return New(NULL); }

  LobbyView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LobbyView& from);
  void MergeFrom(const LobbyView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LobbyView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TableInfo tables = 1;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 1;
  const ::TableInfo& tables(int index) const;
  ::TableInfo* mutable_tables(int index);
  ::TableInfo* add_tables();
  ::google::protobuf::RepeatedPtrField< ::TableInfo >*
      mutable_tables();
  const ::google::protobuf::RepeatedPtrField< ::TableInfo >&
      tables() const;

  // @@protoc_insertion_point(class_scope:LobbyView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TableInfo > tables_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsLobbyViewImpl();
};
// -------------------------------------------------------------------

class TableView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TableView) */ {
 public:
  TableView();
  virtual ~TableView();

  TableView(const TableView& from);

  inline TableView& operator=(const TableView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableView(TableView&& from) noexcept
    : TableView() {
    *this = ::std::move(from);
  }

  inline TableView& operator=(TableView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableView* internal_default_instance() {
    return reinterpret_cast<const TableView*>(
               &_TableView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TableView* other);
  friend void swap(TableView& a, TableView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableView* New() const PROTOBUF_FINAL { return New(NULL); }

  TableView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TableView& from);
  void MergeFrom(const TableView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TableView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Card cards = 3;
  int cards_size() const;
  void clear_cards();
  static const int kCardsFieldNumber = 3;
  const ::Card& cards(int index) const;
  ::Card* mutable_cards(int index);
  ::Card* add_cards();
  ::google::protobuf::RepeatedPtrField< ::Card >*
      mutable_cards();
  const ::google::protobuf::RepeatedPtrField< ::Card >&
      cards() const;

  // repeated uint32 pots = 4;
  int pots_size() const;
  void clear_pots();
  static const int kPotsFieldNumber = 4;
  ::google::protobuf::uint32 pots(int index) const;
  void set_pots(int index, ::google::protobuf::uint32 value);
  void add_pots(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pots() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pots();

  // repeated .Player players = 5;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 5;
  const ::Player& players(int index) const;
  ::Player* mutable_players(int index);
  ::Player* add_players();
  ::google::protobuf::RepeatedPtrField< ::Player >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::Player >&
      players() const;

  // .TableStatus tableStatus = 1;
  void clear_tablestatus();
  static const int kTableStatusFieldNumber = 1;
  ::TableStatus tablestatus() const;
  void set_tablestatus(::TableStatus value);

  // .RoundStatus roundStatus = 2;
  void clear_roundstatus();
  static const int kRoundStatusFieldNumber = 2;
  ::RoundStatus roundstatus() const;
  void set_roundstatus(::RoundStatus value);

  // @@protoc_insertion_point(class_scope:TableView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Card > cards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pots_;
  mutable int _pots_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::Player > players_;
  int tablestatus_;
  int roundstatus_;
  mutable int _cached_size_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
  friend void ::protobuf_protocol_2eproto::InitDefaultsTableViewImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// .Login login = 1;
inline bool Request::has_login() const {
  return payload_case() == kLogin;
}
inline void Request::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void Request::clear_login() {
  if (has_login()) {
    delete payload_.login_;
    clear_has_payload();
  }
}
inline ::Login* Request::release_login() {
  // @@protoc_insertion_point(field_release:Request.login)
  if (has_login()) {
    clear_has_payload();
      ::Login* temp = payload_.login_;
    payload_.login_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Login& Request::login() const {
  // @@protoc_insertion_point(field_get:Request.login)
  return has_login()
      ? *payload_.login_
      : *reinterpret_cast< ::Login*>(&::_Login_default_instance_);
}
inline ::Login* Request::mutable_login() {
  if (!has_login()) {
    clear_payload();
    set_has_login();
    payload_.login_ = new ::Login;
  }
  // @@protoc_insertion_point(field_mutable:Request.login)
  return payload_.login_;
}

// .JoinTable joinTable = 2;
inline bool Request::has_jointable() const {
  return payload_case() == kJoinTable;
}
inline void Request::set_has_jointable() {
  _oneof_case_[0] = kJoinTable;
}
inline void Request::clear_jointable() {
  if (has_jointable()) {
    delete payload_.jointable_;
    clear_has_payload();
  }
}
inline ::JoinTable* Request::release_jointable() {
  // @@protoc_insertion_point(field_release:Request.joinTable)
  if (has_jointable()) {
    clear_has_payload();
      ::JoinTable* temp = payload_.jointable_;
    payload_.jointable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::JoinTable& Request::jointable() const {
  // @@protoc_insertion_point(field_get:Request.joinTable)
  return has_jointable()
      ? *payload_.jointable_
      : *reinterpret_cast< ::JoinTable*>(&::_JoinTable_default_instance_);
}
inline ::JoinTable* Request::mutable_jointable() {
  if (!has_jointable()) {
    clear_payload();
    set_has_jointable();
    payload_.jointable_ = new ::JoinTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.joinTable)
  return payload_.jointable_;
}

// .LeaveTable leaveTable = 3;
inline bool Request::has_leavetable() const {
  return payload_case() == kLeaveTable;
}
inline void Request::set_has_leavetable() {
  _oneof_case_[0] = kLeaveTable;
}
inline void Request::clear_leavetable() {
  if (has_leavetable()) {
    delete payload_.leavetable_;
    clear_has_payload();
  }
}
inline ::LeaveTable* Request::release_leavetable() {
  // @@protoc_insertion_point(field_release:Request.leaveTable)
  if (has_leavetable()) {
    clear_has_payload();
      ::LeaveTable* temp = payload_.leavetable_;
    payload_.leavetable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LeaveTable& Request::leavetable() const {
  // @@protoc_insertion_point(field_get:Request.leaveTable)
  return has_leavetable()
      ? *payload_.leavetable_
      : *reinterpret_cast< ::LeaveTable*>(&::_LeaveTable_default_instance_);
}
inline ::LeaveTable* Request::mutable_leavetable() {
  if (!has_leavetable()) {
    clear_payload();
    set_has_leavetable();
    payload_.leavetable_ = new ::LeaveTable;
  }
  // @@protoc_insertion_point(field_mutable:Request.leaveTable)
  return payload_.leavetable_;
}

// .Raise raise = 4;
inline bool Request::has_raise() const {
  return payload_case() == kRaise;
}
inline void Request::set_has_raise() {
  _oneof_case_[0] = kRaise;
}
inline void Request::clear_raise() {
  if (has_raise()) {
    delete payload_.raise_;
    clear_has_payload();
  }
}
inline ::Raise* Request::release_raise() {
  // @@protoc_insertion_point(field_release:Request.raise)
  if (has_raise()) {
    clear_has_payload();
      ::Raise* temp = payload_.raise_;
    payload_.raise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Raise& Request::raise() const {
  // @@protoc_insertion_point(field_get:Request.raise)
  return has_raise()
      ? *payload_.raise_
      : *reinterpret_cast< ::Raise*>(&::_Raise_default_instance_);
}
inline ::Raise* Request::mutable_raise() {
  if (!has_raise()) {
    clear_payload();
    set_has_raise();
    payload_.raise_ = new ::Raise;
  }
  // @@protoc_insertion_point(field_mutable:Request.raise)
  return payload_.raise_;
}

// .Fold fold = 5;
inline bool Request::has_fold() const {
  return payload_case() == kFold;
}
inline void Request::set_has_fold() {
  _oneof_case_[0] = kFold;
}
inline void Request::clear_fold() {
  if (has_fold()) {
    delete payload_.fold_;
    clear_has_payload();
  }
}
inline ::Fold* Request::release_fold() {
  // @@protoc_insertion_point(field_release:Request.fold)
  if (has_fold()) {
    clear_has_payload();
      ::Fold* temp = payload_.fold_;
    payload_.fold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Fold& Request::fold() const {
  // @@protoc_insertion_point(field_get:Request.fold)
  return has_fold()
      ? *payload_.fold_
      : *reinterpret_cast< ::Fold*>(&::_Fold_default_instance_);
}
inline ::Fold* Request::mutable_fold() {
  if (!has_fold()) {
    clear_payload();
    set_has_fold();
    payload_.fold_ = new ::Fold;
  }
  // @@protoc_insertion_point(field_mutable:Request.fold)
  return payload_.fold_;
}

// .Call call = 6;
inline bool Request::has_call() const {
  return payload_case() == kCall;
}
inline void Request::set_has_call() {
  _oneof_case_[0] = kCall;
}
inline void Request::clear_call() {
  if (has_call()) {
    delete payload_.call_;
    clear_has_payload();
  }
}
inline ::Call* Request::release_call() {
  // @@protoc_insertion_point(field_release:Request.call)
  if (has_call()) {
    clear_has_payload();
      ::Call* temp = payload_.call_;
    payload_.call_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Call& Request::call() const {
  // @@protoc_insertion_point(field_get:Request.call)
  return has_call()
      ? *payload_.call_
      : *reinterpret_cast< ::Call*>(&::_Call_default_instance_);
}
inline ::Call* Request::mutable_call() {
  if (!has_call()) {
    clear_payload();
    set_has_call();
    payload_.call_ = new ::Call;
  }
  // @@protoc_insertion_point(field_mutable:Request.call)
  return payload_.call_;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .Error error = 1;
inline void Response::clear_error() {
  error_ = 0;
}
inline ::Error Response::error() const {
  // @@protoc_insertion_point(field_get:Response.error)
  return static_cast< ::Error >(error_);
}
inline void Response::set_error(::Error value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:Response.error)
}

// .LobbyView lobbyView = 2;
inline bool Response::has_lobbyview() const {
  return payload_case() == kLobbyView;
}
inline void Response::set_has_lobbyview() {
  _oneof_case_[0] = kLobbyView;
}
inline void Response::clear_lobbyview() {
  if (has_lobbyview()) {
    delete payload_.lobbyview_;
    clear_has_payload();
  }
}
inline ::LobbyView* Response::release_lobbyview() {
  // @@protoc_insertion_point(field_release:Response.lobbyView)
  if (has_lobbyview()) {
    clear_has_payload();
      ::LobbyView* temp = payload_.lobbyview_;
    payload_.lobbyview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LobbyView& Response::lobbyview() const {
  // @@protoc_insertion_point(field_get:Response.lobbyView)
  return has_lobbyview()
      ? *payload_.lobbyview_
      : *reinterpret_cast< ::LobbyView*>(&::_LobbyView_default_instance_);
}
inline ::LobbyView* Response::mutable_lobbyview() {
  if (!has_lobbyview()) {
    clear_payload();
    set_has_lobbyview();
    payload_.lobbyview_ = new ::LobbyView;
  }
  // @@protoc_insertion_point(field_mutable:Response.lobbyView)
  return payload_.lobbyview_;
}

// .TableView tableView = 3;
inline bool Response::has_tableview() const {
  return payload_case() == kTableView;
}
inline void Response::set_has_tableview() {
  _oneof_case_[0] = kTableView;
}
inline void Response::clear_tableview() {
  if (has_tableview()) {
    delete payload_.tableview_;
    clear_has_payload();
  }
}
inline ::TableView* Response::release_tableview() {
  // @@protoc_insertion_point(field_release:Response.tableView)
  if (has_tableview()) {
    clear_has_payload();
      ::TableView* temp = payload_.tableview_;
    payload_.tableview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TableView& Response::tableview() const {
  // @@protoc_insertion_point(field_get:Response.tableView)
  return has_tableview()
      ? *payload_.tableview_
      : *reinterpret_cast< ::TableView*>(&::_TableView_default_instance_);
}
inline ::TableView* Response::mutable_tableview() {
  if (!has_tableview()) {
    clear_payload();
    set_has_tableview();
    payload_.tableview_ = new ::TableView;
  }
  // @@protoc_insertion_point(field_mutable:Response.tableView)
  return payload_.tableview_;
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Login

// string username = 1;
inline void Login::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:Login.username)
  return username_.GetNoArena();
}
inline void Login::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.username)
}
#if LANG_CXX11
inline void Login::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.username)
}
#endif
inline void Login::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.username)
}
inline void Login::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.username)
}
inline ::std::string* Login::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Login.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:Login.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Login.username)
}

// -------------------------------------------------------------------

// JoinTable

// uint32 tableId = 1;
inline void JoinTable::clear_tableid() {
  tableid_ = 0u;
}
inline ::google::protobuf::uint32 JoinTable::tableid() const {
  // @@protoc_insertion_point(field_get:JoinTable.tableId)
  return tableid_;
}
inline void JoinTable::set_tableid(::google::protobuf::uint32 value) {
  
  tableid_ = value;
  // @@protoc_insertion_point(field_set:JoinTable.tableId)
}

// -------------------------------------------------------------------

// LeaveTable

// -------------------------------------------------------------------

// Raise

// int32 chips = 1;
inline void Raise::clear_chips() {
  chips_ = 0;
}
inline ::google::protobuf::int32 Raise::chips() const {
  // @@protoc_insertion_point(field_get:Raise.chips)
  return chips_;
}
inline void Raise::set_chips(::google::protobuf::int32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:Raise.chips)
}

// -------------------------------------------------------------------

// Fold

// -------------------------------------------------------------------

// Call

// -------------------------------------------------------------------

// Card

// .CardValue cardValue = 1;
inline void Card::clear_cardvalue() {
  cardvalue_ = 0;
}
inline ::CardValue Card::cardvalue() const {
  // @@protoc_insertion_point(field_get:Card.cardValue)
  return static_cast< ::CardValue >(cardvalue_);
}
inline void Card::set_cardvalue(::CardValue value) {
  
  cardvalue_ = value;
  // @@protoc_insertion_point(field_set:Card.cardValue)
}

// .CardSuit cardSuit = 2;
inline void Card::clear_cardsuit() {
  cardsuit_ = 0;
}
inline ::CardSuit Card::cardsuit() const {
  // @@protoc_insertion_point(field_get:Card.cardSuit)
  return static_cast< ::CardSuit >(cardsuit_);
}
inline void Card::set_cardsuit(::CardSuit value) {
  
  cardsuit_ = value;
  // @@protoc_insertion_point(field_set:Card.cardSuit)
}

// -------------------------------------------------------------------

// Player

// string username = 1;
inline void Player::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::username() const {
  // @@protoc_insertion_point(field_get:Player.username)
  return username_.GetNoArena();
}
inline void Player::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player.username)
}
#if LANG_CXX11
inline void Player::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Player.username)
}
#endif
inline void Player::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player.username)
}
inline void Player::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player.username)
}
inline ::std::string* Player::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Player.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_username() {
  // @@protoc_insertion_point(field_release:Player.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Player.username)
}

// uint32 chips = 2;
inline void Player::clear_chips() {
  chips_ = 0u;
}
inline ::google::protobuf::uint32 Player::chips() const {
  // @@protoc_insertion_point(field_get:Player.chips)
  return chips_;
}
inline void Player::set_chips(::google::protobuf::uint32 value) {
  
  chips_ = value;
  // @@protoc_insertion_point(field_set:Player.chips)
}

// repeated .Card hand = 3;
inline int Player::hand_size() const {
  return hand_.size();
}
inline void Player::clear_hand() {
  hand_.Clear();
}
inline const ::Card& Player::hand(int index) const {
  // @@protoc_insertion_point(field_get:Player.hand)
  return hand_.Get(index);
}
inline ::Card* Player::mutable_hand(int index) {
  // @@protoc_insertion_point(field_mutable:Player.hand)
  return hand_.Mutable(index);
}
inline ::Card* Player::add_hand() {
  // @@protoc_insertion_point(field_add:Player.hand)
  return hand_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Card >*
Player::mutable_hand() {
  // @@protoc_insertion_point(field_mutable_list:Player.hand)
  return &hand_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Card >&
Player::hand() const {
  // @@protoc_insertion_point(field_list:Player.hand)
  return hand_;
}

// bool dealer = 4;
inline void Player::clear_dealer() {
  dealer_ = false;
}
inline bool Player::dealer() const {
  // @@protoc_insertion_point(field_get:Player.dealer)
  return dealer_;
}
inline void Player::set_dealer(bool value) {
  
  dealer_ = value;
  // @@protoc_insertion_point(field_set:Player.dealer)
}

// -------------------------------------------------------------------

// TableInfo

// uint32 index = 1;
inline void TableInfo::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 TableInfo::index() const {
  // @@protoc_insertion_point(field_get:TableInfo.index)
  return index_;
}
inline void TableInfo::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:TableInfo.index)
}

// string name = 2;
inline void TableInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableInfo::name() const {
  // @@protoc_insertion_point(field_get:TableInfo.name)
  return name_.GetNoArena();
}
inline void TableInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TableInfo.name)
}
#if LANG_CXX11
inline void TableInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TableInfo.name)
}
#endif
inline void TableInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TableInfo.name)
}
inline void TableInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TableInfo.name)
}
inline ::std::string* TableInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:TableInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableInfo::release_name() {
  // @@protoc_insertion_point(field_release:TableInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:TableInfo.name)
}

// uint32 maxPlayers = 3;
inline void TableInfo::clear_maxplayers() {
  maxplayers_ = 0u;
}
inline ::google::protobuf::uint32 TableInfo::maxplayers() const {
  // @@protoc_insertion_point(field_get:TableInfo.maxPlayers)
  return maxplayers_;
}
inline void TableInfo::set_maxplayers(::google::protobuf::uint32 value) {
  
  maxplayers_ = value;
  // @@protoc_insertion_point(field_set:TableInfo.maxPlayers)
}

// uint32 players = 4;
inline void TableInfo::clear_players() {
  players_ = 0u;
}
inline ::google::protobuf::uint32 TableInfo::players() const {
  // @@protoc_insertion_point(field_get:TableInfo.players)
  return players_;
}
inline void TableInfo::set_players(::google::protobuf::uint32 value) {
  
  players_ = value;
  // @@protoc_insertion_point(field_set:TableInfo.players)
}

// -------------------------------------------------------------------

// LobbyView

// repeated .TableInfo tables = 1;
inline int LobbyView::tables_size() const {
  return tables_.size();
}
inline void LobbyView::clear_tables() {
  tables_.Clear();
}
inline const ::TableInfo& LobbyView::tables(int index) const {
  // @@protoc_insertion_point(field_get:LobbyView.tables)
  return tables_.Get(index);
}
inline ::TableInfo* LobbyView::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:LobbyView.tables)
  return tables_.Mutable(index);
}
inline ::TableInfo* LobbyView::add_tables() {
  // @@protoc_insertion_point(field_add:LobbyView.tables)
  return tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TableInfo >*
LobbyView::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:LobbyView.tables)
  return &tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TableInfo >&
LobbyView::tables() const {
  // @@protoc_insertion_point(field_list:LobbyView.tables)
  return tables_;
}

// -------------------------------------------------------------------

// TableView

// .TableStatus tableStatus = 1;
inline void TableView::clear_tablestatus() {
  tablestatus_ = 0;
}
inline ::TableStatus TableView::tablestatus() const {
  // @@protoc_insertion_point(field_get:TableView.tableStatus)
  return static_cast< ::TableStatus >(tablestatus_);
}
inline void TableView::set_tablestatus(::TableStatus value) {
  
  tablestatus_ = value;
  // @@protoc_insertion_point(field_set:TableView.tableStatus)
}

// .RoundStatus roundStatus = 2;
inline void TableView::clear_roundstatus() {
  roundstatus_ = 0;
}
inline ::RoundStatus TableView::roundstatus() const {
  // @@protoc_insertion_point(field_get:TableView.roundStatus)
  return static_cast< ::RoundStatus >(roundstatus_);
}
inline void TableView::set_roundstatus(::RoundStatus value) {
  
  roundstatus_ = value;
  // @@protoc_insertion_point(field_set:TableView.roundStatus)
}

// repeated .Card cards = 3;
inline int TableView::cards_size() const {
  return cards_.size();
}
inline void TableView::clear_cards() {
  cards_.Clear();
}
inline const ::Card& TableView::cards(int index) const {
  // @@protoc_insertion_point(field_get:TableView.cards)
  return cards_.Get(index);
}
inline ::Card* TableView::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:TableView.cards)
  return cards_.Mutable(index);
}
inline ::Card* TableView::add_cards() {
  // @@protoc_insertion_point(field_add:TableView.cards)
  return cards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Card >*
TableView::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:TableView.cards)
  return &cards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Card >&
TableView::cards() const {
  // @@protoc_insertion_point(field_list:TableView.cards)
  return cards_;
}

// repeated uint32 pots = 4;
inline int TableView::pots_size() const {
  return pots_.size();
}
inline void TableView::clear_pots() {
  pots_.Clear();
}
inline ::google::protobuf::uint32 TableView::pots(int index) const {
  // @@protoc_insertion_point(field_get:TableView.pots)
  return pots_.Get(index);
}
inline void TableView::set_pots(int index, ::google::protobuf::uint32 value) {
  pots_.Set(index, value);
  // @@protoc_insertion_point(field_set:TableView.pots)
}
inline void TableView::add_pots(::google::protobuf::uint32 value) {
  pots_.Add(value);
  // @@protoc_insertion_point(field_add:TableView.pots)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TableView::pots() const {
  // @@protoc_insertion_point(field_list:TableView.pots)
  return pots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TableView::mutable_pots() {
  // @@protoc_insertion_point(field_mutable_list:TableView.pots)
  return &pots_;
}

// repeated .Player players = 5;
inline int TableView::players_size() const {
  return players_.size();
}
inline void TableView::clear_players() {
  players_.Clear();
}
inline const ::Player& TableView::players(int index) const {
  // @@protoc_insertion_point(field_get:TableView.players)
  return players_.Get(index);
}
inline ::Player* TableView::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:TableView.players)
  return players_.Mutable(index);
}
inline ::Player* TableView::add_players() {
  // @@protoc_insertion_point(field_add:TableView.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Player >*
TableView::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:TableView.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Player >&
TableView::players() const {
  // @@protoc_insertion_point(field_list:TableView.players)
  return players_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Error> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Error>() {
  return ::Error_descriptor();
}
template <> struct is_proto_enum< ::TableStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TableStatus>() {
  return ::TableStatus_descriptor();
}
template <> struct is_proto_enum< ::RoundStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoundStatus>() {
  return ::RoundStatus_descriptor();
}
template <> struct is_proto_enum< ::CardValue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CardValue>() {
  return ::CardValue_descriptor();
}
template <> struct is_proto_enum< ::CardSuit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CardSuit>() {
  return ::CardSuit_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
